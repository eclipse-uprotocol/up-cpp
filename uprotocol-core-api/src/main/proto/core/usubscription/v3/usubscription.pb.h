// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: core/usubscription/v3/usubscription.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_core_2fusubscription_2fv3_2fusubscription_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_core_2fusubscription_2fv3_2fusubscription_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include "ustatus.pb.h"
#include "uri.pb.h"
#include "uprotocol_options.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_core_2fusubscription_2fv3_2fusubscription_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_core_2fusubscription_2fv3_2fusubscription_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_core_2fusubscription_2fv3_2fusubscription_2eproto;
namespace uprotocol {
namespace core {
namespace usubscription {
namespace v3 {
class CreateTopicRequest;
struct CreateTopicRequestDefaultTypeInternal;
extern CreateTopicRequestDefaultTypeInternal _CreateTopicRequest_default_instance_;
class DeprecateTopicRequest;
struct DeprecateTopicRequestDefaultTypeInternal;
extern DeprecateTopicRequestDefaultTypeInternal _DeprecateTopicRequest_default_instance_;
class EventDeliveryConfig;
struct EventDeliveryConfigDefaultTypeInternal;
extern EventDeliveryConfigDefaultTypeInternal _EventDeliveryConfig_default_instance_;
class EventDeliveryConfig_AttributesEntry_DoNotUse;
struct EventDeliveryConfig_AttributesEntry_DoNotUseDefaultTypeInternal;
extern EventDeliveryConfig_AttributesEntry_DoNotUseDefaultTypeInternal _EventDeliveryConfig_AttributesEntry_DoNotUse_default_instance_;
class FetchSubscribersRequest;
struct FetchSubscribersRequestDefaultTypeInternal;
extern FetchSubscribersRequestDefaultTypeInternal _FetchSubscribersRequest_default_instance_;
class FetchSubscribersResponse;
struct FetchSubscribersResponseDefaultTypeInternal;
extern FetchSubscribersResponseDefaultTypeInternal _FetchSubscribersResponse_default_instance_;
class FetchSubscriptionsRequest;
struct FetchSubscriptionsRequestDefaultTypeInternal;
extern FetchSubscriptionsRequestDefaultTypeInternal _FetchSubscriptionsRequest_default_instance_;
class FetchSubscriptionsResponse;
struct FetchSubscriptionsResponseDefaultTypeInternal;
extern FetchSubscriptionsResponseDefaultTypeInternal _FetchSubscriptionsResponse_default_instance_;
class NotificationsRequest;
struct NotificationsRequestDefaultTypeInternal;
extern NotificationsRequestDefaultTypeInternal _NotificationsRequest_default_instance_;
class PassiveMode;
struct PassiveModeDefaultTypeInternal;
extern PassiveModeDefaultTypeInternal _PassiveMode_default_instance_;
class ResetRequest;
struct ResetRequestDefaultTypeInternal;
extern ResetRequestDefaultTypeInternal _ResetRequest_default_instance_;
class ResetRequest_Reason;
struct ResetRequest_ReasonDefaultTypeInternal;
extern ResetRequest_ReasonDefaultTypeInternal _ResetRequest_Reason_default_instance_;
class SubscribeAttributes;
struct SubscribeAttributesDefaultTypeInternal;
extern SubscribeAttributesDefaultTypeInternal _SubscribeAttributes_default_instance_;
class SubscriberInfo;
struct SubscriberInfoDefaultTypeInternal;
extern SubscriberInfoDefaultTypeInternal _SubscriberInfo_default_instance_;
class Subscription;
struct SubscriptionDefaultTypeInternal;
extern SubscriptionDefaultTypeInternal _Subscription_default_instance_;
class SubscriptionChangeNotification;
struct SubscriptionChangeNotificationDefaultTypeInternal;
extern SubscriptionChangeNotificationDefaultTypeInternal _SubscriptionChangeNotification_default_instance_;
class SubscriptionRequest;
struct SubscriptionRequestDefaultTypeInternal;
extern SubscriptionRequestDefaultTypeInternal _SubscriptionRequest_default_instance_;
class SubscriptionResponse;
struct SubscriptionResponseDefaultTypeInternal;
extern SubscriptionResponseDefaultTypeInternal _SubscriptionResponse_default_instance_;
class SubscriptionStatus;
struct SubscriptionStatusDefaultTypeInternal;
extern SubscriptionStatusDefaultTypeInternal _SubscriptionStatus_default_instance_;
class UnsubscribeRequest;
struct UnsubscribeRequestDefaultTypeInternal;
extern UnsubscribeRequestDefaultTypeInternal _UnsubscribeRequest_default_instance_;
class Update;
struct UpdateDefaultTypeInternal;
extern UpdateDefaultTypeInternal _Update_default_instance_;
}  // namespace v3
}  // namespace usubscription
}  // namespace core
}  // namespace uprotocol
PROTOBUF_NAMESPACE_OPEN
template<> ::uprotocol::core::usubscription::v3::CreateTopicRequest* Arena::CreateMaybeMessage<::uprotocol::core::usubscription::v3::CreateTopicRequest>(Arena*);
template<> ::uprotocol::core::usubscription::v3::DeprecateTopicRequest* Arena::CreateMaybeMessage<::uprotocol::core::usubscription::v3::DeprecateTopicRequest>(Arena*);
template<> ::uprotocol::core::usubscription::v3::EventDeliveryConfig* Arena::CreateMaybeMessage<::uprotocol::core::usubscription::v3::EventDeliveryConfig>(Arena*);
template<> ::uprotocol::core::usubscription::v3::EventDeliveryConfig_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::uprotocol::core::usubscription::v3::EventDeliveryConfig_AttributesEntry_DoNotUse>(Arena*);
template<> ::uprotocol::core::usubscription::v3::FetchSubscribersRequest* Arena::CreateMaybeMessage<::uprotocol::core::usubscription::v3::FetchSubscribersRequest>(Arena*);
template<> ::uprotocol::core::usubscription::v3::FetchSubscribersResponse* Arena::CreateMaybeMessage<::uprotocol::core::usubscription::v3::FetchSubscribersResponse>(Arena*);
template<> ::uprotocol::core::usubscription::v3::FetchSubscriptionsRequest* Arena::CreateMaybeMessage<::uprotocol::core::usubscription::v3::FetchSubscriptionsRequest>(Arena*);
template<> ::uprotocol::core::usubscription::v3::FetchSubscriptionsResponse* Arena::CreateMaybeMessage<::uprotocol::core::usubscription::v3::FetchSubscriptionsResponse>(Arena*);
template<> ::uprotocol::core::usubscription::v3::NotificationsRequest* Arena::CreateMaybeMessage<::uprotocol::core::usubscription::v3::NotificationsRequest>(Arena*);
template<> ::uprotocol::core::usubscription::v3::PassiveMode* Arena::CreateMaybeMessage<::uprotocol::core::usubscription::v3::PassiveMode>(Arena*);
template<> ::uprotocol::core::usubscription::v3::ResetRequest* Arena::CreateMaybeMessage<::uprotocol::core::usubscription::v3::ResetRequest>(Arena*);
template<> ::uprotocol::core::usubscription::v3::ResetRequest_Reason* Arena::CreateMaybeMessage<::uprotocol::core::usubscription::v3::ResetRequest_Reason>(Arena*);
template<> ::uprotocol::core::usubscription::v3::SubscribeAttributes* Arena::CreateMaybeMessage<::uprotocol::core::usubscription::v3::SubscribeAttributes>(Arena*);
template<> ::uprotocol::core::usubscription::v3::SubscriberInfo* Arena::CreateMaybeMessage<::uprotocol::core::usubscription::v3::SubscriberInfo>(Arena*);
template<> ::uprotocol::core::usubscription::v3::Subscription* Arena::CreateMaybeMessage<::uprotocol::core::usubscription::v3::Subscription>(Arena*);
template<> ::uprotocol::core::usubscription::v3::SubscriptionChangeNotification* Arena::CreateMaybeMessage<::uprotocol::core::usubscription::v3::SubscriptionChangeNotification>(Arena*);
template<> ::uprotocol::core::usubscription::v3::SubscriptionRequest* Arena::CreateMaybeMessage<::uprotocol::core::usubscription::v3::SubscriptionRequest>(Arena*);
template<> ::uprotocol::core::usubscription::v3::SubscriptionResponse* Arena::CreateMaybeMessage<::uprotocol::core::usubscription::v3::SubscriptionResponse>(Arena*);
template<> ::uprotocol::core::usubscription::v3::SubscriptionStatus* Arena::CreateMaybeMessage<::uprotocol::core::usubscription::v3::SubscriptionStatus>(Arena*);
template<> ::uprotocol::core::usubscription::v3::UnsubscribeRequest* Arena::CreateMaybeMessage<::uprotocol::core::usubscription::v3::UnsubscribeRequest>(Arena*);
template<> ::uprotocol::core::usubscription::v3::Update* Arena::CreateMaybeMessage<::uprotocol::core::usubscription::v3::Update>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace uprotocol {
namespace core {
namespace usubscription {
namespace v3 {

enum SubscriptionStatus_State : int {
  SubscriptionStatus_State_UNSUBSCRIBED = 0,
  SubscriptionStatus_State_SUBSCRIBE_PENDING = 1,
  SubscriptionStatus_State_SUBSCRIBED = 2,
  SubscriptionStatus_State_UNSUBSCRIBE_PENDING = 3,
  SubscriptionStatus_State_SubscriptionStatus_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SubscriptionStatus_State_SubscriptionStatus_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SubscriptionStatus_State_IsValid(int value);
constexpr SubscriptionStatus_State SubscriptionStatus_State_State_MIN = SubscriptionStatus_State_UNSUBSCRIBED;
constexpr SubscriptionStatus_State SubscriptionStatus_State_State_MAX = SubscriptionStatus_State_UNSUBSCRIBE_PENDING;
constexpr int SubscriptionStatus_State_State_ARRAYSIZE = SubscriptionStatus_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SubscriptionStatus_State_descriptor();
template<typename T>
inline const std::string& SubscriptionStatus_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SubscriptionStatus_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SubscriptionStatus_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SubscriptionStatus_State_descriptor(), enum_t_value);
}
inline bool SubscriptionStatus_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SubscriptionStatus_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SubscriptionStatus_State>(
    SubscriptionStatus_State_descriptor(), name, value);
}
enum Update_Resources : int {
  Update_Resources_subscriptions = 0,
  Update_Resources_Update_Resources_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Update_Resources_Update_Resources_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Update_Resources_IsValid(int value);
constexpr Update_Resources Update_Resources_Resources_MIN = Update_Resources_subscriptions;
constexpr Update_Resources Update_Resources_Resources_MAX = Update_Resources_subscriptions;
constexpr int Update_Resources_Resources_ARRAYSIZE = Update_Resources_Resources_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Update_Resources_descriptor();
template<typename T>
inline const std::string& Update_Resources_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Update_Resources>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Update_Resources_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Update_Resources_descriptor(), enum_t_value);
}
inline bool Update_Resources_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Update_Resources* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Update_Resources>(
    Update_Resources_descriptor(), name, value);
}
enum ResetRequest_Reason_Code : int {
  ResetRequest_Reason_Code_UNSPECIFIED = 0,
  ResetRequest_Reason_Code_FACTORY_RESET = 1,
  ResetRequest_Reason_Code_CORRUPTED_DATA = 2,
  ResetRequest_Reason_Code_ResetRequest_Reason_Code_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ResetRequest_Reason_Code_ResetRequest_Reason_Code_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ResetRequest_Reason_Code_IsValid(int value);
constexpr ResetRequest_Reason_Code ResetRequest_Reason_Code_Code_MIN = ResetRequest_Reason_Code_UNSPECIFIED;
constexpr ResetRequest_Reason_Code ResetRequest_Reason_Code_Code_MAX = ResetRequest_Reason_Code_CORRUPTED_DATA;
constexpr int ResetRequest_Reason_Code_Code_ARRAYSIZE = ResetRequest_Reason_Code_Code_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResetRequest_Reason_Code_descriptor();
template<typename T>
inline const std::string& ResetRequest_Reason_Code_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResetRequest_Reason_Code>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResetRequest_Reason_Code_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResetRequest_Reason_Code_descriptor(), enum_t_value);
}
inline bool ResetRequest_Reason_Code_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResetRequest_Reason_Code* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResetRequest_Reason_Code>(
    ResetRequest_Reason_Code_descriptor(), name, value);
}
// ===================================================================

class SubscribeAttributes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uprotocol.core.usubscription.v3.SubscribeAttributes) */ {
 public:
  inline SubscribeAttributes() : SubscribeAttributes(nullptr) {}
  ~SubscribeAttributes() override;
  explicit PROTOBUF_CONSTEXPR SubscribeAttributes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeAttributes(const SubscribeAttributes& from);
  SubscribeAttributes(SubscribeAttributes&& from) noexcept
    : SubscribeAttributes() {
    *this = ::std::move(from);
  }

  inline SubscribeAttributes& operator=(const SubscribeAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeAttributes& operator=(SubscribeAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeAttributes* internal_default_instance() {
    return reinterpret_cast<const SubscribeAttributes*>(
               &_SubscribeAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SubscribeAttributes& a, SubscribeAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeAttributes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeAttributes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeAttributes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscribeAttributes& from) {
    SubscribeAttributes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeAttributes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uprotocol.core.usubscription.v3.SubscribeAttributes";
  }
  protected:
  explicit SubscribeAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetailsFieldNumber = 2,
    kExpireFieldNumber = 1,
  };
  // repeated .google.protobuf.Any details = 2;
  int details_size() const;
  private:
  int _internal_details_size() const;
  public:
  void clear_details();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_details(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_details();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_details(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_add_details();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Any& details(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* add_details();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
      details() const;

  // .google.protobuf.Timestamp expire = 1;
  bool has_expire() const;
  private:
  bool _internal_has_expire() const;
  public:
  void clear_expire();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& expire() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_expire();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_expire();
  void set_allocated_expire(::PROTOBUF_NAMESPACE_ID::Timestamp* expire);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_expire() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_expire();
  public:
  void unsafe_arena_set_allocated_expire(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* expire);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_expire();

  // @@protoc_insertion_point(class_scope:uprotocol.core.usubscription.v3.SubscribeAttributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any > details_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* expire_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2fusubscription_2fv3_2fusubscription_2eproto;
};
// -------------------------------------------------------------------

class SubscriberInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uprotocol.core.usubscription.v3.SubscriberInfo) */ {
 public:
  inline SubscriberInfo() : SubscriberInfo(nullptr) {}
  ~SubscriberInfo() override;
  explicit PROTOBUF_CONSTEXPR SubscriberInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriberInfo(const SubscriberInfo& from);
  SubscriberInfo(SubscriberInfo&& from) noexcept
    : SubscriberInfo() {
    *this = ::std::move(from);
  }

  inline SubscriberInfo& operator=(const SubscriberInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriberInfo& operator=(SubscriberInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriberInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriberInfo* internal_default_instance() {
    return reinterpret_cast<const SubscriberInfo*>(
               &_SubscriberInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SubscriberInfo& a, SubscriberInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriberInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriberInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriberInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscriberInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriberInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscriberInfo& from) {
    SubscriberInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriberInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uprotocol.core.usubscription.v3.SubscriberInfo";
  }
  protected:
  explicit SubscriberInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetailsFieldNumber = 2,
    kUriFieldNumber = 1,
  };
  // repeated .google.protobuf.Any details = 2;
  int details_size() const;
  private:
  int _internal_details_size() const;
  public:
  void clear_details();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_details(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_details();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_details(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_add_details();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Any& details(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* add_details();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
      details() const;

  // .uprotocol.v1.UUri uri = 1;
  bool has_uri() const;
  private:
  bool _internal_has_uri() const;
  public:
  void clear_uri();
  const ::uprotocol::v1::UUri& uri() const;
  PROTOBUF_NODISCARD ::uprotocol::v1::UUri* release_uri();
  ::uprotocol::v1::UUri* mutable_uri();
  void set_allocated_uri(::uprotocol::v1::UUri* uri);
  private:
  const ::uprotocol::v1::UUri& _internal_uri() const;
  ::uprotocol::v1::UUri* _internal_mutable_uri();
  public:
  void unsafe_arena_set_allocated_uri(
      ::uprotocol::v1::UUri* uri);
  ::uprotocol::v1::UUri* unsafe_arena_release_uri();

  // @@protoc_insertion_point(class_scope:uprotocol.core.usubscription.v3.SubscriberInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any > details_;
    ::uprotocol::v1::UUri* uri_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2fusubscription_2fv3_2fusubscription_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uprotocol.core.usubscription.v3.SubscriptionStatus) */ {
 public:
  inline SubscriptionStatus() : SubscriptionStatus(nullptr) {}
  ~SubscriptionStatus() override;
  explicit PROTOBUF_CONSTEXPR SubscriptionStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionStatus(const SubscriptionStatus& from);
  SubscriptionStatus(SubscriptionStatus&& from) noexcept
    : SubscriptionStatus() {
    *this = ::std::move(from);
  }

  inline SubscriptionStatus& operator=(const SubscriptionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionStatus& operator=(SubscriptionStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionStatus* internal_default_instance() {
    return reinterpret_cast<const SubscriptionStatus*>(
               &_SubscriptionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SubscriptionStatus& a, SubscriptionStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscriptionStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscriptionStatus& from) {
    SubscriptionStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uprotocol.core.usubscription.v3.SubscriptionStatus";
  }
  protected:
  explicit SubscriptionStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SubscriptionStatus_State State;
  static constexpr State UNSUBSCRIBED =
    SubscriptionStatus_State_UNSUBSCRIBED;
  static constexpr State SUBSCRIBE_PENDING =
    SubscriptionStatus_State_SUBSCRIBE_PENDING;
  static constexpr State SUBSCRIBED =
    SubscriptionStatus_State_SUBSCRIBED;
  static constexpr State UNSUBSCRIBE_PENDING =
    SubscriptionStatus_State_UNSUBSCRIBE_PENDING;
  static inline bool State_IsValid(int value) {
    return SubscriptionStatus_State_IsValid(value);
  }
  static constexpr State State_MIN =
    SubscriptionStatus_State_State_MIN;
  static constexpr State State_MAX =
    SubscriptionStatus_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    SubscriptionStatus_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return SubscriptionStatus_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return SubscriptionStatus_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return SubscriptionStatus_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kStateFieldNumber = 1,
    kCodeFieldNumber = 2,
  };
  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .uprotocol.core.usubscription.v3.SubscriptionStatus.State state = 1;
  void clear_state();
  ::uprotocol::core::usubscription::v3::SubscriptionStatus_State state() const;
  void set_state(::uprotocol::core::usubscription::v3::SubscriptionStatus_State value);
  private:
  ::uprotocol::core::usubscription::v3::SubscriptionStatus_State _internal_state() const;
  void _internal_set_state(::uprotocol::core::usubscription::v3::SubscriptionStatus_State value);
  public:

  // .uprotocol.v1.UCode code = 2;
  void clear_code();
  ::uprotocol::v1::UCode code() const;
  void set_code(::uprotocol::v1::UCode value);
  private:
  ::uprotocol::v1::UCode _internal_code() const;
  void _internal_set_code(::uprotocol::v1::UCode value);
  public:

  // @@protoc_insertion_point(class_scope:uprotocol.core.usubscription.v3.SubscriptionStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int state_;
    int code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2fusubscription_2fv3_2fusubscription_2eproto;
};
// -------------------------------------------------------------------

class EventDeliveryConfig_AttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<EventDeliveryConfig_AttributesEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<EventDeliveryConfig_AttributesEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  EventDeliveryConfig_AttributesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR EventDeliveryConfig_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit EventDeliveryConfig_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const EventDeliveryConfig_AttributesEntry_DoNotUse& other);
  static const EventDeliveryConfig_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const EventDeliveryConfig_AttributesEntry_DoNotUse*>(&_EventDeliveryConfig_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "uprotocol.core.usubscription.v3.EventDeliveryConfig.AttributesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_core_2fusubscription_2fv3_2fusubscription_2eproto;
};

// -------------------------------------------------------------------

class EventDeliveryConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uprotocol.core.usubscription.v3.EventDeliveryConfig) */ {
 public:
  inline EventDeliveryConfig() : EventDeliveryConfig(nullptr) {}
  ~EventDeliveryConfig() override;
  explicit PROTOBUF_CONSTEXPR EventDeliveryConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventDeliveryConfig(const EventDeliveryConfig& from);
  EventDeliveryConfig(EventDeliveryConfig&& from) noexcept
    : EventDeliveryConfig() {
    *this = ::std::move(from);
  }

  inline EventDeliveryConfig& operator=(const EventDeliveryConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventDeliveryConfig& operator=(EventDeliveryConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventDeliveryConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventDeliveryConfig* internal_default_instance() {
    return reinterpret_cast<const EventDeliveryConfig*>(
               &_EventDeliveryConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EventDeliveryConfig& a, EventDeliveryConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(EventDeliveryConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventDeliveryConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventDeliveryConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventDeliveryConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventDeliveryConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventDeliveryConfig& from) {
    EventDeliveryConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventDeliveryConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uprotocol.core.usubscription.v3.EventDeliveryConfig";
  }
  protected:
  explicit EventDeliveryConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 3,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // map<string, .google.protobuf.Any> attributes = 3;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_attributes();

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string type = 2;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:uprotocol.core.usubscription.v3.EventDeliveryConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        EventDeliveryConfig_AttributesEntry_DoNotUse,
        std::string, ::PROTOBUF_NAMESPACE_ID::Any,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2fusubscription_2fv3_2fusubscription_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uprotocol.core.usubscription.v3.SubscriptionRequest) */ {
 public:
  inline SubscriptionRequest() : SubscriptionRequest(nullptr) {}
  ~SubscriptionRequest() override;
  explicit PROTOBUF_CONSTEXPR SubscriptionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionRequest(const SubscriptionRequest& from);
  SubscriptionRequest(SubscriptionRequest&& from) noexcept
    : SubscriptionRequest() {
    *this = ::std::move(from);
  }

  inline SubscriptionRequest& operator=(const SubscriptionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionRequest& operator=(SubscriptionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionRequest* internal_default_instance() {
    return reinterpret_cast<const SubscriptionRequest*>(
               &_SubscriptionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SubscriptionRequest& a, SubscriptionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscriptionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscriptionRequest& from) {
    SubscriptionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uprotocol.core.usubscription.v3.SubscriptionRequest";
  }
  protected:
  explicit SubscriptionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
    kSubscriberFieldNumber = 2,
    kAttributesFieldNumber = 3,
  };
  // .uprotocol.v1.UUri topic = 1;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const ::uprotocol::v1::UUri& topic() const;
  PROTOBUF_NODISCARD ::uprotocol::v1::UUri* release_topic();
  ::uprotocol::v1::UUri* mutable_topic();
  void set_allocated_topic(::uprotocol::v1::UUri* topic);
  private:
  const ::uprotocol::v1::UUri& _internal_topic() const;
  ::uprotocol::v1::UUri* _internal_mutable_topic();
  public:
  void unsafe_arena_set_allocated_topic(
      ::uprotocol::v1::UUri* topic);
  ::uprotocol::v1::UUri* unsafe_arena_release_topic();

  // .uprotocol.core.usubscription.v3.SubscriberInfo subscriber = 2;
  bool has_subscriber() const;
  private:
  bool _internal_has_subscriber() const;
  public:
  void clear_subscriber();
  const ::uprotocol::core::usubscription::v3::SubscriberInfo& subscriber() const;
  PROTOBUF_NODISCARD ::uprotocol::core::usubscription::v3::SubscriberInfo* release_subscriber();
  ::uprotocol::core::usubscription::v3::SubscriberInfo* mutable_subscriber();
  void set_allocated_subscriber(::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber);
  private:
  const ::uprotocol::core::usubscription::v3::SubscriberInfo& _internal_subscriber() const;
  ::uprotocol::core::usubscription::v3::SubscriberInfo* _internal_mutable_subscriber();
  public:
  void unsafe_arena_set_allocated_subscriber(
      ::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber);
  ::uprotocol::core::usubscription::v3::SubscriberInfo* unsafe_arena_release_subscriber();

  // .uprotocol.core.usubscription.v3.SubscribeAttributes attributes = 3;
  bool has_attributes() const;
  private:
  bool _internal_has_attributes() const;
  public:
  void clear_attributes();
  const ::uprotocol::core::usubscription::v3::SubscribeAttributes& attributes() const;
  PROTOBUF_NODISCARD ::uprotocol::core::usubscription::v3::SubscribeAttributes* release_attributes();
  ::uprotocol::core::usubscription::v3::SubscribeAttributes* mutable_attributes();
  void set_allocated_attributes(::uprotocol::core::usubscription::v3::SubscribeAttributes* attributes);
  private:
  const ::uprotocol::core::usubscription::v3::SubscribeAttributes& _internal_attributes() const;
  ::uprotocol::core::usubscription::v3::SubscribeAttributes* _internal_mutable_attributes();
  public:
  void unsafe_arena_set_allocated_attributes(
      ::uprotocol::core::usubscription::v3::SubscribeAttributes* attributes);
  ::uprotocol::core::usubscription::v3::SubscribeAttributes* unsafe_arena_release_attributes();

  // @@protoc_insertion_point(class_scope:uprotocol.core.usubscription.v3.SubscriptionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uprotocol::v1::UUri* topic_;
    ::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber_;
    ::uprotocol::core::usubscription::v3::SubscribeAttributes* attributes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2fusubscription_2fv3_2fusubscription_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uprotocol.core.usubscription.v3.SubscriptionResponse) */ {
 public:
  inline SubscriptionResponse() : SubscriptionResponse(nullptr) {}
  ~SubscriptionResponse() override;
  explicit PROTOBUF_CONSTEXPR SubscriptionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionResponse(const SubscriptionResponse& from);
  SubscriptionResponse(SubscriptionResponse&& from) noexcept
    : SubscriptionResponse() {
    *this = ::std::move(from);
  }

  inline SubscriptionResponse& operator=(const SubscriptionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionResponse& operator=(SubscriptionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionResponse* internal_default_instance() {
    return reinterpret_cast<const SubscriptionResponse*>(
               &_SubscriptionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SubscriptionResponse& a, SubscriptionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscriptionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscriptionResponse& from) {
    SubscriptionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uprotocol.core.usubscription.v3.SubscriptionResponse";
  }
  protected:
  explicit SubscriptionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kConfigFieldNumber = 2,
    kTopicFieldNumber = 3,
  };
  // .uprotocol.core.usubscription.v3.SubscriptionStatus status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::uprotocol::core::usubscription::v3::SubscriptionStatus& status() const;
  PROTOBUF_NODISCARD ::uprotocol::core::usubscription::v3::SubscriptionStatus* release_status();
  ::uprotocol::core::usubscription::v3::SubscriptionStatus* mutable_status();
  void set_allocated_status(::uprotocol::core::usubscription::v3::SubscriptionStatus* status);
  private:
  const ::uprotocol::core::usubscription::v3::SubscriptionStatus& _internal_status() const;
  ::uprotocol::core::usubscription::v3::SubscriptionStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::uprotocol::core::usubscription::v3::SubscriptionStatus* status);
  ::uprotocol::core::usubscription::v3::SubscriptionStatus* unsafe_arena_release_status();

  // .uprotocol.core.usubscription.v3.EventDeliveryConfig config = 2;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::uprotocol::core::usubscription::v3::EventDeliveryConfig& config() const;
  PROTOBUF_NODISCARD ::uprotocol::core::usubscription::v3::EventDeliveryConfig* release_config();
  ::uprotocol::core::usubscription::v3::EventDeliveryConfig* mutable_config();
  void set_allocated_config(::uprotocol::core::usubscription::v3::EventDeliveryConfig* config);
  private:
  const ::uprotocol::core::usubscription::v3::EventDeliveryConfig& _internal_config() const;
  ::uprotocol::core::usubscription::v3::EventDeliveryConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::uprotocol::core::usubscription::v3::EventDeliveryConfig* config);
  ::uprotocol::core::usubscription::v3::EventDeliveryConfig* unsafe_arena_release_config();

  // .uprotocol.v1.UUri topic = 3;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const ::uprotocol::v1::UUri& topic() const;
  PROTOBUF_NODISCARD ::uprotocol::v1::UUri* release_topic();
  ::uprotocol::v1::UUri* mutable_topic();
  void set_allocated_topic(::uprotocol::v1::UUri* topic);
  private:
  const ::uprotocol::v1::UUri& _internal_topic() const;
  ::uprotocol::v1::UUri* _internal_mutable_topic();
  public:
  void unsafe_arena_set_allocated_topic(
      ::uprotocol::v1::UUri* topic);
  ::uprotocol::v1::UUri* unsafe_arena_release_topic();

  // @@protoc_insertion_point(class_scope:uprotocol.core.usubscription.v3.SubscriptionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uprotocol::core::usubscription::v3::SubscriptionStatus* status_;
    ::uprotocol::core::usubscription::v3::EventDeliveryConfig* config_;
    ::uprotocol::v1::UUri* topic_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2fusubscription_2fv3_2fusubscription_2eproto;
};
// -------------------------------------------------------------------

class UnsubscribeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uprotocol.core.usubscription.v3.UnsubscribeRequest) */ {
 public:
  inline UnsubscribeRequest() : UnsubscribeRequest(nullptr) {}
  ~UnsubscribeRequest() override;
  explicit PROTOBUF_CONSTEXPR UnsubscribeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnsubscribeRequest(const UnsubscribeRequest& from);
  UnsubscribeRequest(UnsubscribeRequest&& from) noexcept
    : UnsubscribeRequest() {
    *this = ::std::move(from);
  }

  inline UnsubscribeRequest& operator=(const UnsubscribeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnsubscribeRequest& operator=(UnsubscribeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnsubscribeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnsubscribeRequest* internal_default_instance() {
    return reinterpret_cast<const UnsubscribeRequest*>(
               &_UnsubscribeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UnsubscribeRequest& a, UnsubscribeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UnsubscribeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnsubscribeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnsubscribeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnsubscribeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnsubscribeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnsubscribeRequest& from) {
    UnsubscribeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnsubscribeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uprotocol.core.usubscription.v3.UnsubscribeRequest";
  }
  protected:
  explicit UnsubscribeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
    kSubscriberFieldNumber = 2,
  };
  // .uprotocol.v1.UUri topic = 1;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const ::uprotocol::v1::UUri& topic() const;
  PROTOBUF_NODISCARD ::uprotocol::v1::UUri* release_topic();
  ::uprotocol::v1::UUri* mutable_topic();
  void set_allocated_topic(::uprotocol::v1::UUri* topic);
  private:
  const ::uprotocol::v1::UUri& _internal_topic() const;
  ::uprotocol::v1::UUri* _internal_mutable_topic();
  public:
  void unsafe_arena_set_allocated_topic(
      ::uprotocol::v1::UUri* topic);
  ::uprotocol::v1::UUri* unsafe_arena_release_topic();

  // .uprotocol.core.usubscription.v3.SubscriberInfo subscriber = 2;
  bool has_subscriber() const;
  private:
  bool _internal_has_subscriber() const;
  public:
  void clear_subscriber();
  const ::uprotocol::core::usubscription::v3::SubscriberInfo& subscriber() const;
  PROTOBUF_NODISCARD ::uprotocol::core::usubscription::v3::SubscriberInfo* release_subscriber();
  ::uprotocol::core::usubscription::v3::SubscriberInfo* mutable_subscriber();
  void set_allocated_subscriber(::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber);
  private:
  const ::uprotocol::core::usubscription::v3::SubscriberInfo& _internal_subscriber() const;
  ::uprotocol::core::usubscription::v3::SubscriberInfo* _internal_mutable_subscriber();
  public:
  void unsafe_arena_set_allocated_subscriber(
      ::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber);
  ::uprotocol::core::usubscription::v3::SubscriberInfo* unsafe_arena_release_subscriber();

  // @@protoc_insertion_point(class_scope:uprotocol.core.usubscription.v3.UnsubscribeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uprotocol::v1::UUri* topic_;
    ::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2fusubscription_2fv3_2fusubscription_2eproto;
};
// -------------------------------------------------------------------

class FetchSubscribersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uprotocol.core.usubscription.v3.FetchSubscribersRequest) */ {
 public:
  inline FetchSubscribersRequest() : FetchSubscribersRequest(nullptr) {}
  ~FetchSubscribersRequest() override;
  explicit PROTOBUF_CONSTEXPR FetchSubscribersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchSubscribersRequest(const FetchSubscribersRequest& from);
  FetchSubscribersRequest(FetchSubscribersRequest&& from) noexcept
    : FetchSubscribersRequest() {
    *this = ::std::move(from);
  }

  inline FetchSubscribersRequest& operator=(const FetchSubscribersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchSubscribersRequest& operator=(FetchSubscribersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchSubscribersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchSubscribersRequest* internal_default_instance() {
    return reinterpret_cast<const FetchSubscribersRequest*>(
               &_FetchSubscribersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FetchSubscribersRequest& a, FetchSubscribersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchSubscribersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchSubscribersRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchSubscribersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchSubscribersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchSubscribersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FetchSubscribersRequest& from) {
    FetchSubscribersRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchSubscribersRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uprotocol.core.usubscription.v3.FetchSubscribersRequest";
  }
  protected:
  explicit FetchSubscribersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
    kOffsetFieldNumber = 2,
  };
  // .uprotocol.v1.UUri topic = 1;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const ::uprotocol::v1::UUri& topic() const;
  PROTOBUF_NODISCARD ::uprotocol::v1::UUri* release_topic();
  ::uprotocol::v1::UUri* mutable_topic();
  void set_allocated_topic(::uprotocol::v1::UUri* topic);
  private:
  const ::uprotocol::v1::UUri& _internal_topic() const;
  ::uprotocol::v1::UUri* _internal_mutable_topic();
  public:
  void unsafe_arena_set_allocated_topic(
      ::uprotocol::v1::UUri* topic);
  ::uprotocol::v1::UUri* unsafe_arena_release_topic();

  // optional uint32 offset = 2;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  uint32_t offset() const;
  void set_offset(uint32_t value);
  private:
  uint32_t _internal_offset() const;
  void _internal_set_offset(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:uprotocol.core.usubscription.v3.FetchSubscribersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uprotocol::v1::UUri* topic_;
    uint32_t offset_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2fusubscription_2fv3_2fusubscription_2eproto;
};
// -------------------------------------------------------------------

class FetchSubscribersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uprotocol.core.usubscription.v3.FetchSubscribersResponse) */ {
 public:
  inline FetchSubscribersResponse() : FetchSubscribersResponse(nullptr) {}
  ~FetchSubscribersResponse() override;
  explicit PROTOBUF_CONSTEXPR FetchSubscribersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchSubscribersResponse(const FetchSubscribersResponse& from);
  FetchSubscribersResponse(FetchSubscribersResponse&& from) noexcept
    : FetchSubscribersResponse() {
    *this = ::std::move(from);
  }

  inline FetchSubscribersResponse& operator=(const FetchSubscribersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchSubscribersResponse& operator=(FetchSubscribersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchSubscribersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchSubscribersResponse* internal_default_instance() {
    return reinterpret_cast<const FetchSubscribersResponse*>(
               &_FetchSubscribersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FetchSubscribersResponse& a, FetchSubscribersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchSubscribersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchSubscribersResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchSubscribersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchSubscribersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchSubscribersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FetchSubscribersResponse& from) {
    FetchSubscribersResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchSubscribersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uprotocol.core.usubscription.v3.FetchSubscribersResponse";
  }
  protected:
  explicit FetchSubscribersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscribersFieldNumber = 1,
    kStatusFieldNumber = 3,
    kHasMoreRecordsFieldNumber = 2,
  };
  // repeated .uprotocol.core.usubscription.v3.SubscriberInfo subscribers = 1;
  int subscribers_size() const;
  private:
  int _internal_subscribers_size() const;
  public:
  void clear_subscribers();
  ::uprotocol::core::usubscription::v3::SubscriberInfo* mutable_subscribers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uprotocol::core::usubscription::v3::SubscriberInfo >*
      mutable_subscribers();
  private:
  const ::uprotocol::core::usubscription::v3::SubscriberInfo& _internal_subscribers(int index) const;
  ::uprotocol::core::usubscription::v3::SubscriberInfo* _internal_add_subscribers();
  public:
  const ::uprotocol::core::usubscription::v3::SubscriberInfo& subscribers(int index) const;
  ::uprotocol::core::usubscription::v3::SubscriberInfo* add_subscribers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uprotocol::core::usubscription::v3::SubscriberInfo >&
      subscribers() const;

  // .uprotocol.v1.UStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::uprotocol::v1::UStatus& status() const;
  PROTOBUF_NODISCARD ::uprotocol::v1::UStatus* release_status();
  ::uprotocol::v1::UStatus* mutable_status();
  void set_allocated_status(::uprotocol::v1::UStatus* status);
  private:
  const ::uprotocol::v1::UStatus& _internal_status() const;
  ::uprotocol::v1::UStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::uprotocol::v1::UStatus* status);
  ::uprotocol::v1::UStatus* unsafe_arena_release_status();

  // optional bool has_more_records = 2;
  bool has_has_more_records() const;
  private:
  bool _internal_has_has_more_records() const;
  public:
  void clear_has_more_records();
  bool has_more_records() const;
  void set_has_more_records(bool value);
  private:
  bool _internal_has_more_records() const;
  void _internal_set_has_more_records(bool value);
  public:

  // @@protoc_insertion_point(class_scope:uprotocol.core.usubscription.v3.FetchSubscribersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uprotocol::core::usubscription::v3::SubscriberInfo > subscribers_;
    ::uprotocol::v1::UStatus* status_;
    bool has_more_records_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2fusubscription_2fv3_2fusubscription_2eproto;
};
// -------------------------------------------------------------------

class Subscription final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uprotocol.core.usubscription.v3.Subscription) */ {
 public:
  inline Subscription() : Subscription(nullptr) {}
  ~Subscription() override;
  explicit PROTOBUF_CONSTEXPR Subscription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Subscription(const Subscription& from);
  Subscription(Subscription&& from) noexcept
    : Subscription() {
    *this = ::std::move(from);
  }

  inline Subscription& operator=(const Subscription& from) {
    CopyFrom(from);
    return *this;
  }
  inline Subscription& operator=(Subscription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Subscription& default_instance() {
    return *internal_default_instance();
  }
  static inline const Subscription* internal_default_instance() {
    return reinterpret_cast<const Subscription*>(
               &_Subscription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Subscription& a, Subscription& b) {
    a.Swap(&b);
  }
  inline void Swap(Subscription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Subscription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Subscription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Subscription>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Subscription& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Subscription& from) {
    Subscription::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Subscription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uprotocol.core.usubscription.v3.Subscription";
  }
  protected:
  explicit Subscription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
    kSubscriberFieldNumber = 2,
    kStatusFieldNumber = 3,
    kAttributesFieldNumber = 4,
    kConfigFieldNumber = 5,
  };
  // .uprotocol.v1.UUri topic = 1;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const ::uprotocol::v1::UUri& topic() const;
  PROTOBUF_NODISCARD ::uprotocol::v1::UUri* release_topic();
  ::uprotocol::v1::UUri* mutable_topic();
  void set_allocated_topic(::uprotocol::v1::UUri* topic);
  private:
  const ::uprotocol::v1::UUri& _internal_topic() const;
  ::uprotocol::v1::UUri* _internal_mutable_topic();
  public:
  void unsafe_arena_set_allocated_topic(
      ::uprotocol::v1::UUri* topic);
  ::uprotocol::v1::UUri* unsafe_arena_release_topic();

  // .uprotocol.core.usubscription.v3.SubscriberInfo subscriber = 2;
  bool has_subscriber() const;
  private:
  bool _internal_has_subscriber() const;
  public:
  void clear_subscriber();
  const ::uprotocol::core::usubscription::v3::SubscriberInfo& subscriber() const;
  PROTOBUF_NODISCARD ::uprotocol::core::usubscription::v3::SubscriberInfo* release_subscriber();
  ::uprotocol::core::usubscription::v3::SubscriberInfo* mutable_subscriber();
  void set_allocated_subscriber(::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber);
  private:
  const ::uprotocol::core::usubscription::v3::SubscriberInfo& _internal_subscriber() const;
  ::uprotocol::core::usubscription::v3::SubscriberInfo* _internal_mutable_subscriber();
  public:
  void unsafe_arena_set_allocated_subscriber(
      ::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber);
  ::uprotocol::core::usubscription::v3::SubscriberInfo* unsafe_arena_release_subscriber();

  // .uprotocol.core.usubscription.v3.SubscriptionStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::uprotocol::core::usubscription::v3::SubscriptionStatus& status() const;
  PROTOBUF_NODISCARD ::uprotocol::core::usubscription::v3::SubscriptionStatus* release_status();
  ::uprotocol::core::usubscription::v3::SubscriptionStatus* mutable_status();
  void set_allocated_status(::uprotocol::core::usubscription::v3::SubscriptionStatus* status);
  private:
  const ::uprotocol::core::usubscription::v3::SubscriptionStatus& _internal_status() const;
  ::uprotocol::core::usubscription::v3::SubscriptionStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::uprotocol::core::usubscription::v3::SubscriptionStatus* status);
  ::uprotocol::core::usubscription::v3::SubscriptionStatus* unsafe_arena_release_status();

  // .uprotocol.core.usubscription.v3.SubscribeAttributes attributes = 4;
  bool has_attributes() const;
  private:
  bool _internal_has_attributes() const;
  public:
  void clear_attributes();
  const ::uprotocol::core::usubscription::v3::SubscribeAttributes& attributes() const;
  PROTOBUF_NODISCARD ::uprotocol::core::usubscription::v3::SubscribeAttributes* release_attributes();
  ::uprotocol::core::usubscription::v3::SubscribeAttributes* mutable_attributes();
  void set_allocated_attributes(::uprotocol::core::usubscription::v3::SubscribeAttributes* attributes);
  private:
  const ::uprotocol::core::usubscription::v3::SubscribeAttributes& _internal_attributes() const;
  ::uprotocol::core::usubscription::v3::SubscribeAttributes* _internal_mutable_attributes();
  public:
  void unsafe_arena_set_allocated_attributes(
      ::uprotocol::core::usubscription::v3::SubscribeAttributes* attributes);
  ::uprotocol::core::usubscription::v3::SubscribeAttributes* unsafe_arena_release_attributes();

  // .uprotocol.core.usubscription.v3.EventDeliveryConfig config = 5;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::uprotocol::core::usubscription::v3::EventDeliveryConfig& config() const;
  PROTOBUF_NODISCARD ::uprotocol::core::usubscription::v3::EventDeliveryConfig* release_config();
  ::uprotocol::core::usubscription::v3::EventDeliveryConfig* mutable_config();
  void set_allocated_config(::uprotocol::core::usubscription::v3::EventDeliveryConfig* config);
  private:
  const ::uprotocol::core::usubscription::v3::EventDeliveryConfig& _internal_config() const;
  ::uprotocol::core::usubscription::v3::EventDeliveryConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::uprotocol::core::usubscription::v3::EventDeliveryConfig* config);
  ::uprotocol::core::usubscription::v3::EventDeliveryConfig* unsafe_arena_release_config();

  // @@protoc_insertion_point(class_scope:uprotocol.core.usubscription.v3.Subscription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uprotocol::v1::UUri* topic_;
    ::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber_;
    ::uprotocol::core::usubscription::v3::SubscriptionStatus* status_;
    ::uprotocol::core::usubscription::v3::SubscribeAttributes* attributes_;
    ::uprotocol::core::usubscription::v3::EventDeliveryConfig* config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2fusubscription_2fv3_2fusubscription_2eproto;
};
// -------------------------------------------------------------------

class FetchSubscriptionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uprotocol.core.usubscription.v3.FetchSubscriptionsRequest) */ {
 public:
  inline FetchSubscriptionsRequest() : FetchSubscriptionsRequest(nullptr) {}
  ~FetchSubscriptionsRequest() override;
  explicit PROTOBUF_CONSTEXPR FetchSubscriptionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchSubscriptionsRequest(const FetchSubscriptionsRequest& from);
  FetchSubscriptionsRequest(FetchSubscriptionsRequest&& from) noexcept
    : FetchSubscriptionsRequest() {
    *this = ::std::move(from);
  }

  inline FetchSubscriptionsRequest& operator=(const FetchSubscriptionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchSubscriptionsRequest& operator=(FetchSubscriptionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchSubscriptionsRequest& default_instance() {
    return *internal_default_instance();
  }
  enum RequestCase {
    kTopic = 1,
    kSubscriber = 2,
    REQUEST_NOT_SET = 0,
  };

  static inline const FetchSubscriptionsRequest* internal_default_instance() {
    return reinterpret_cast<const FetchSubscriptionsRequest*>(
               &_FetchSubscriptionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(FetchSubscriptionsRequest& a, FetchSubscriptionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchSubscriptionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchSubscriptionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchSubscriptionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchSubscriptionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchSubscriptionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FetchSubscriptionsRequest& from) {
    FetchSubscriptionsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchSubscriptionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uprotocol.core.usubscription.v3.FetchSubscriptionsRequest";
  }
  protected:
  explicit FetchSubscriptionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetFieldNumber = 3,
    kTopicFieldNumber = 1,
    kSubscriberFieldNumber = 2,
  };
  // optional uint32 offset = 3;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  uint32_t offset() const;
  void set_offset(uint32_t value);
  private:
  uint32_t _internal_offset() const;
  void _internal_set_offset(uint32_t value);
  public:

  // .uprotocol.v1.UUri topic = 1;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const ::uprotocol::v1::UUri& topic() const;
  PROTOBUF_NODISCARD ::uprotocol::v1::UUri* release_topic();
  ::uprotocol::v1::UUri* mutable_topic();
  void set_allocated_topic(::uprotocol::v1::UUri* topic);
  private:
  const ::uprotocol::v1::UUri& _internal_topic() const;
  ::uprotocol::v1::UUri* _internal_mutable_topic();
  public:
  void unsafe_arena_set_allocated_topic(
      ::uprotocol::v1::UUri* topic);
  ::uprotocol::v1::UUri* unsafe_arena_release_topic();

  // .uprotocol.core.usubscription.v3.SubscriberInfo subscriber = 2;
  bool has_subscriber() const;
  private:
  bool _internal_has_subscriber() const;
  public:
  void clear_subscriber();
  const ::uprotocol::core::usubscription::v3::SubscriberInfo& subscriber() const;
  PROTOBUF_NODISCARD ::uprotocol::core::usubscription::v3::SubscriberInfo* release_subscriber();
  ::uprotocol::core::usubscription::v3::SubscriberInfo* mutable_subscriber();
  void set_allocated_subscriber(::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber);
  private:
  const ::uprotocol::core::usubscription::v3::SubscriberInfo& _internal_subscriber() const;
  ::uprotocol::core::usubscription::v3::SubscriberInfo* _internal_mutable_subscriber();
  public:
  void unsafe_arena_set_allocated_subscriber(
      ::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber);
  ::uprotocol::core::usubscription::v3::SubscriberInfo* unsafe_arena_release_subscriber();

  void clear_request();
  RequestCase request_case() const;
  // @@protoc_insertion_point(class_scope:uprotocol.core.usubscription.v3.FetchSubscriptionsRequest)
 private:
  class _Internal;
  void set_has_topic();
  void set_has_subscriber();

  inline bool has_request() const;
  inline void clear_has_request();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t offset_;
    union RequestUnion {
      constexpr RequestUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::uprotocol::v1::UUri* topic_;
      ::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber_;
    } request_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2fusubscription_2fv3_2fusubscription_2eproto;
};
// -------------------------------------------------------------------

class FetchSubscriptionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uprotocol.core.usubscription.v3.FetchSubscriptionsResponse) */ {
 public:
  inline FetchSubscriptionsResponse() : FetchSubscriptionsResponse(nullptr) {}
  ~FetchSubscriptionsResponse() override;
  explicit PROTOBUF_CONSTEXPR FetchSubscriptionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchSubscriptionsResponse(const FetchSubscriptionsResponse& from);
  FetchSubscriptionsResponse(FetchSubscriptionsResponse&& from) noexcept
    : FetchSubscriptionsResponse() {
    *this = ::std::move(from);
  }

  inline FetchSubscriptionsResponse& operator=(const FetchSubscriptionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchSubscriptionsResponse& operator=(FetchSubscriptionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchSubscriptionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchSubscriptionsResponse* internal_default_instance() {
    return reinterpret_cast<const FetchSubscriptionsResponse*>(
               &_FetchSubscriptionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FetchSubscriptionsResponse& a, FetchSubscriptionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchSubscriptionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchSubscriptionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchSubscriptionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchSubscriptionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchSubscriptionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FetchSubscriptionsResponse& from) {
    FetchSubscriptionsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchSubscriptionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uprotocol.core.usubscription.v3.FetchSubscriptionsResponse";
  }
  protected:
  explicit FetchSubscriptionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriptionsFieldNumber = 1,
    kStatusFieldNumber = 3,
    kHasMoreRecordsFieldNumber = 2,
  };
  // repeated .uprotocol.core.usubscription.v3.Subscription subscriptions = 1;
  int subscriptions_size() const;
  private:
  int _internal_subscriptions_size() const;
  public:
  void clear_subscriptions();
  ::uprotocol::core::usubscription::v3::Subscription* mutable_subscriptions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uprotocol::core::usubscription::v3::Subscription >*
      mutable_subscriptions();
  private:
  const ::uprotocol::core::usubscription::v3::Subscription& _internal_subscriptions(int index) const;
  ::uprotocol::core::usubscription::v3::Subscription* _internal_add_subscriptions();
  public:
  const ::uprotocol::core::usubscription::v3::Subscription& subscriptions(int index) const;
  ::uprotocol::core::usubscription::v3::Subscription* add_subscriptions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uprotocol::core::usubscription::v3::Subscription >&
      subscriptions() const;

  // .uprotocol.v1.UStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::uprotocol::v1::UStatus& status() const;
  PROTOBUF_NODISCARD ::uprotocol::v1::UStatus* release_status();
  ::uprotocol::v1::UStatus* mutable_status();
  void set_allocated_status(::uprotocol::v1::UStatus* status);
  private:
  const ::uprotocol::v1::UStatus& _internal_status() const;
  ::uprotocol::v1::UStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::uprotocol::v1::UStatus* status);
  ::uprotocol::v1::UStatus* unsafe_arena_release_status();

  // optional bool has_more_records = 2;
  bool has_has_more_records() const;
  private:
  bool _internal_has_has_more_records() const;
  public:
  void clear_has_more_records();
  bool has_more_records() const;
  void set_has_more_records(bool value);
  private:
  bool _internal_has_more_records() const;
  void _internal_set_has_more_records(bool value);
  public:

  // @@protoc_insertion_point(class_scope:uprotocol.core.usubscription.v3.FetchSubscriptionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uprotocol::core::usubscription::v3::Subscription > subscriptions_;
    ::uprotocol::v1::UStatus* status_;
    bool has_more_records_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2fusubscription_2fv3_2fusubscription_2eproto;
};
// -------------------------------------------------------------------

class NotificationsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uprotocol.core.usubscription.v3.NotificationsRequest) */ {
 public:
  inline NotificationsRequest() : NotificationsRequest(nullptr) {}
  ~NotificationsRequest() override;
  explicit PROTOBUF_CONSTEXPR NotificationsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotificationsRequest(const NotificationsRequest& from);
  NotificationsRequest(NotificationsRequest&& from) noexcept
    : NotificationsRequest() {
    *this = ::std::move(from);
  }

  inline NotificationsRequest& operator=(const NotificationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotificationsRequest& operator=(NotificationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotificationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotificationsRequest* internal_default_instance() {
    return reinterpret_cast<const NotificationsRequest*>(
               &_NotificationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(NotificationsRequest& a, NotificationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NotificationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotificationsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotificationsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotificationsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotificationsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotificationsRequest& from) {
    NotificationsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotificationsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uprotocol.core.usubscription.v3.NotificationsRequest";
  }
  protected:
  explicit NotificationsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
    kSubscriberFieldNumber = 2,
  };
  // .uprotocol.v1.UUri topic = 1;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const ::uprotocol::v1::UUri& topic() const;
  PROTOBUF_NODISCARD ::uprotocol::v1::UUri* release_topic();
  ::uprotocol::v1::UUri* mutable_topic();
  void set_allocated_topic(::uprotocol::v1::UUri* topic);
  private:
  const ::uprotocol::v1::UUri& _internal_topic() const;
  ::uprotocol::v1::UUri* _internal_mutable_topic();
  public:
  void unsafe_arena_set_allocated_topic(
      ::uprotocol::v1::UUri* topic);
  ::uprotocol::v1::UUri* unsafe_arena_release_topic();

  // .uprotocol.core.usubscription.v3.SubscriberInfo subscriber = 2;
  bool has_subscriber() const;
  private:
  bool _internal_has_subscriber() const;
  public:
  void clear_subscriber();
  const ::uprotocol::core::usubscription::v3::SubscriberInfo& subscriber() const;
  PROTOBUF_NODISCARD ::uprotocol::core::usubscription::v3::SubscriberInfo* release_subscriber();
  ::uprotocol::core::usubscription::v3::SubscriberInfo* mutable_subscriber();
  void set_allocated_subscriber(::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber);
  private:
  const ::uprotocol::core::usubscription::v3::SubscriberInfo& _internal_subscriber() const;
  ::uprotocol::core::usubscription::v3::SubscriberInfo* _internal_mutable_subscriber();
  public:
  void unsafe_arena_set_allocated_subscriber(
      ::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber);
  ::uprotocol::core::usubscription::v3::SubscriberInfo* unsafe_arena_release_subscriber();

  // @@protoc_insertion_point(class_scope:uprotocol.core.usubscription.v3.NotificationsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uprotocol::v1::UUri* topic_;
    ::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2fusubscription_2fv3_2fusubscription_2eproto;
};
// -------------------------------------------------------------------

class CreateTopicRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uprotocol.core.usubscription.v3.CreateTopicRequest) */ {
 public:
  inline CreateTopicRequest() : CreateTopicRequest(nullptr) {}
  ~CreateTopicRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateTopicRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTopicRequest(const CreateTopicRequest& from);
  CreateTopicRequest(CreateTopicRequest&& from) noexcept
    : CreateTopicRequest() {
    *this = ::std::move(from);
  }

  inline CreateTopicRequest& operator=(const CreateTopicRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTopicRequest& operator=(CreateTopicRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTopicRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTopicRequest* internal_default_instance() {
    return reinterpret_cast<const CreateTopicRequest*>(
               &_CreateTopicRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CreateTopicRequest& a, CreateTopicRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTopicRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTopicRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTopicRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateTopicRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTopicRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateTopicRequest& from) {
    CreateTopicRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTopicRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uprotocol.core.usubscription.v3.CreateTopicRequest";
  }
  protected:
  explicit CreateTopicRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
  };
  // .uprotocol.v1.UUri topic = 1;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const ::uprotocol::v1::UUri& topic() const;
  PROTOBUF_NODISCARD ::uprotocol::v1::UUri* release_topic();
  ::uprotocol::v1::UUri* mutable_topic();
  void set_allocated_topic(::uprotocol::v1::UUri* topic);
  private:
  const ::uprotocol::v1::UUri& _internal_topic() const;
  ::uprotocol::v1::UUri* _internal_mutable_topic();
  public:
  void unsafe_arena_set_allocated_topic(
      ::uprotocol::v1::UUri* topic);
  ::uprotocol::v1::UUri* unsafe_arena_release_topic();

  // @@protoc_insertion_point(class_scope:uprotocol.core.usubscription.v3.CreateTopicRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uprotocol::v1::UUri* topic_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2fusubscription_2fv3_2fusubscription_2eproto;
};
// -------------------------------------------------------------------

class DeprecateTopicRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uprotocol.core.usubscription.v3.DeprecateTopicRequest) */ {
 public:
  inline DeprecateTopicRequest() : DeprecateTopicRequest(nullptr) {}
  ~DeprecateTopicRequest() override;
  explicit PROTOBUF_CONSTEXPR DeprecateTopicRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeprecateTopicRequest(const DeprecateTopicRequest& from);
  DeprecateTopicRequest(DeprecateTopicRequest&& from) noexcept
    : DeprecateTopicRequest() {
    *this = ::std::move(from);
  }

  inline DeprecateTopicRequest& operator=(const DeprecateTopicRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeprecateTopicRequest& operator=(DeprecateTopicRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeprecateTopicRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeprecateTopicRequest* internal_default_instance() {
    return reinterpret_cast<const DeprecateTopicRequest*>(
               &_DeprecateTopicRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(DeprecateTopicRequest& a, DeprecateTopicRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeprecateTopicRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeprecateTopicRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeprecateTopicRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeprecateTopicRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeprecateTopicRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeprecateTopicRequest& from) {
    DeprecateTopicRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeprecateTopicRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uprotocol.core.usubscription.v3.DeprecateTopicRequest";
  }
  protected:
  explicit DeprecateTopicRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
  };
  // .uprotocol.v1.UUri topic = 1;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const ::uprotocol::v1::UUri& topic() const;
  PROTOBUF_NODISCARD ::uprotocol::v1::UUri* release_topic();
  ::uprotocol::v1::UUri* mutable_topic();
  void set_allocated_topic(::uprotocol::v1::UUri* topic);
  private:
  const ::uprotocol::v1::UUri& _internal_topic() const;
  ::uprotocol::v1::UUri* _internal_mutable_topic();
  public:
  void unsafe_arena_set_allocated_topic(
      ::uprotocol::v1::UUri* topic);
  ::uprotocol::v1::UUri* unsafe_arena_release_topic();

  // @@protoc_insertion_point(class_scope:uprotocol.core.usubscription.v3.DeprecateTopicRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uprotocol::v1::UUri* topic_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2fusubscription_2fv3_2fusubscription_2eproto;
};
// -------------------------------------------------------------------

class Update final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uprotocol.core.usubscription.v3.Update) */ {
 public:
  inline Update() : Update(nullptr) {}
  ~Update() override;
  explicit PROTOBUF_CONSTEXPR Update(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Update(const Update& from);
  Update(Update&& from) noexcept
    : Update() {
    *this = ::std::move(from);
  }

  inline Update& operator=(const Update& from) {
    CopyFrom(from);
    return *this;
  }
  inline Update& operator=(Update&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Update& default_instance() {
    return *internal_default_instance();
  }
  static inline const Update* internal_default_instance() {
    return reinterpret_cast<const Update*>(
               &_Update_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Update& a, Update& b) {
    a.Swap(&b);
  }
  inline void Swap(Update* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Update* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Update* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Update>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Update& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Update& from) {
    Update::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Update* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uprotocol.core.usubscription.v3.Update";
  }
  protected:
  explicit Update(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Update_Resources Resources;
  static constexpr Resources subscriptions =
    Update_Resources_subscriptions;
  static inline bool Resources_IsValid(int value) {
    return Update_Resources_IsValid(value);
  }
  static constexpr Resources Resources_MIN =
    Update_Resources_Resources_MIN;
  static constexpr Resources Resources_MAX =
    Update_Resources_Resources_MAX;
  static constexpr int Resources_ARRAYSIZE =
    Update_Resources_Resources_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Resources_descriptor() {
    return Update_Resources_descriptor();
  }
  template<typename T>
  static inline const std::string& Resources_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Resources>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Resources_Name.");
    return Update_Resources_Name(enum_t_value);
  }
  static inline bool Resources_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Resources* value) {
    return Update_Resources_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
    kSubscriberFieldNumber = 2,
    kStatusFieldNumber = 3,
    kAttributesFieldNumber = 4,
  };
  // .uprotocol.v1.UUri topic = 1;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const ::uprotocol::v1::UUri& topic() const;
  PROTOBUF_NODISCARD ::uprotocol::v1::UUri* release_topic();
  ::uprotocol::v1::UUri* mutable_topic();
  void set_allocated_topic(::uprotocol::v1::UUri* topic);
  private:
  const ::uprotocol::v1::UUri& _internal_topic() const;
  ::uprotocol::v1::UUri* _internal_mutable_topic();
  public:
  void unsafe_arena_set_allocated_topic(
      ::uprotocol::v1::UUri* topic);
  ::uprotocol::v1::UUri* unsafe_arena_release_topic();

  // .uprotocol.core.usubscription.v3.SubscriberInfo subscriber = 2;
  bool has_subscriber() const;
  private:
  bool _internal_has_subscriber() const;
  public:
  void clear_subscriber();
  const ::uprotocol::core::usubscription::v3::SubscriberInfo& subscriber() const;
  PROTOBUF_NODISCARD ::uprotocol::core::usubscription::v3::SubscriberInfo* release_subscriber();
  ::uprotocol::core::usubscription::v3::SubscriberInfo* mutable_subscriber();
  void set_allocated_subscriber(::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber);
  private:
  const ::uprotocol::core::usubscription::v3::SubscriberInfo& _internal_subscriber() const;
  ::uprotocol::core::usubscription::v3::SubscriberInfo* _internal_mutable_subscriber();
  public:
  void unsafe_arena_set_allocated_subscriber(
      ::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber);
  ::uprotocol::core::usubscription::v3::SubscriberInfo* unsafe_arena_release_subscriber();

  // .uprotocol.core.usubscription.v3.SubscriptionStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::uprotocol::core::usubscription::v3::SubscriptionStatus& status() const;
  PROTOBUF_NODISCARD ::uprotocol::core::usubscription::v3::SubscriptionStatus* release_status();
  ::uprotocol::core::usubscription::v3::SubscriptionStatus* mutable_status();
  void set_allocated_status(::uprotocol::core::usubscription::v3::SubscriptionStatus* status);
  private:
  const ::uprotocol::core::usubscription::v3::SubscriptionStatus& _internal_status() const;
  ::uprotocol::core::usubscription::v3::SubscriptionStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::uprotocol::core::usubscription::v3::SubscriptionStatus* status);
  ::uprotocol::core::usubscription::v3::SubscriptionStatus* unsafe_arena_release_status();

  // .uprotocol.core.usubscription.v3.SubscribeAttributes attributes = 4;
  bool has_attributes() const;
  private:
  bool _internal_has_attributes() const;
  public:
  void clear_attributes();
  const ::uprotocol::core::usubscription::v3::SubscribeAttributes& attributes() const;
  PROTOBUF_NODISCARD ::uprotocol::core::usubscription::v3::SubscribeAttributes* release_attributes();
  ::uprotocol::core::usubscription::v3::SubscribeAttributes* mutable_attributes();
  void set_allocated_attributes(::uprotocol::core::usubscription::v3::SubscribeAttributes* attributes);
  private:
  const ::uprotocol::core::usubscription::v3::SubscribeAttributes& _internal_attributes() const;
  ::uprotocol::core::usubscription::v3::SubscribeAttributes* _internal_mutable_attributes();
  public:
  void unsafe_arena_set_allocated_attributes(
      ::uprotocol::core::usubscription::v3::SubscribeAttributes* attributes);
  ::uprotocol::core::usubscription::v3::SubscribeAttributes* unsafe_arena_release_attributes();

  // @@protoc_insertion_point(class_scope:uprotocol.core.usubscription.v3.Update)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uprotocol::v1::UUri* topic_;
    ::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber_;
    ::uprotocol::core::usubscription::v3::SubscriptionStatus* status_;
    ::uprotocol::core::usubscription::v3::SubscribeAttributes* attributes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2fusubscription_2fv3_2fusubscription_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionChangeNotification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uprotocol.core.usubscription.v3.SubscriptionChangeNotification) */ {
 public:
  inline SubscriptionChangeNotification() : SubscriptionChangeNotification(nullptr) {}
  ~SubscriptionChangeNotification() override;
  explicit PROTOBUF_CONSTEXPR SubscriptionChangeNotification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionChangeNotification(const SubscriptionChangeNotification& from);
  SubscriptionChangeNotification(SubscriptionChangeNotification&& from) noexcept
    : SubscriptionChangeNotification() {
    *this = ::std::move(from);
  }

  inline SubscriptionChangeNotification& operator=(const SubscriptionChangeNotification& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionChangeNotification& operator=(SubscriptionChangeNotification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionChangeNotification& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionChangeNotification* internal_default_instance() {
    return reinterpret_cast<const SubscriptionChangeNotification*>(
               &_SubscriptionChangeNotification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SubscriptionChangeNotification& a, SubscriptionChangeNotification& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionChangeNotification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionChangeNotification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionChangeNotification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscriptionChangeNotification>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionChangeNotification& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscriptionChangeNotification& from) {
    SubscriptionChangeNotification::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionChangeNotification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uprotocol.core.usubscription.v3.SubscriptionChangeNotification";
  }
  protected:
  explicit SubscriptionChangeNotification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceNameFieldNumber = 1,
  };
  // .uprotocol.core.usubscription.v3.Update.Resources resource_name = 1 [(.uprotocol.resource_name_mask) = "*"];
  void clear_resource_name();
  ::uprotocol::core::usubscription::v3::Update_Resources resource_name() const;
  void set_resource_name(::uprotocol::core::usubscription::v3::Update_Resources value);
  private:
  ::uprotocol::core::usubscription::v3::Update_Resources _internal_resource_name() const;
  void _internal_set_resource_name(::uprotocol::core::usubscription::v3::Update_Resources value);
  public:

  // @@protoc_insertion_point(class_scope:uprotocol.core.usubscription.v3.SubscriptionChangeNotification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int resource_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2fusubscription_2fv3_2fusubscription_2eproto;
};
// -------------------------------------------------------------------

class PassiveMode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uprotocol.core.usubscription.v3.PassiveMode) */ {
 public:
  inline PassiveMode() : PassiveMode(nullptr) {}
  ~PassiveMode() override;
  explicit PROTOBUF_CONSTEXPR PassiveMode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PassiveMode(const PassiveMode& from);
  PassiveMode(PassiveMode&& from) noexcept
    : PassiveMode() {
    *this = ::std::move(from);
  }

  inline PassiveMode& operator=(const PassiveMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline PassiveMode& operator=(PassiveMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PassiveMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const PassiveMode* internal_default_instance() {
    return reinterpret_cast<const PassiveMode*>(
               &_PassiveMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(PassiveMode& a, PassiveMode& b) {
    a.Swap(&b);
  }
  inline void Swap(PassiveMode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PassiveMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PassiveMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PassiveMode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PassiveMode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PassiveMode& from) {
    PassiveMode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PassiveMode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uprotocol.core.usubscription.v3.PassiveMode";
  }
  protected:
  explicit PassiveMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableFieldNumber = 1,
  };
  // bool enable = 1;
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:uprotocol.core.usubscription.v3.PassiveMode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool enable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2fusubscription_2fv3_2fusubscription_2eproto;
};
// -------------------------------------------------------------------

class ResetRequest_Reason final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uprotocol.core.usubscription.v3.ResetRequest.Reason) */ {
 public:
  inline ResetRequest_Reason() : ResetRequest_Reason(nullptr) {}
  ~ResetRequest_Reason() override;
  explicit PROTOBUF_CONSTEXPR ResetRequest_Reason(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetRequest_Reason(const ResetRequest_Reason& from);
  ResetRequest_Reason(ResetRequest_Reason&& from) noexcept
    : ResetRequest_Reason() {
    *this = ::std::move(from);
  }

  inline ResetRequest_Reason& operator=(const ResetRequest_Reason& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetRequest_Reason& operator=(ResetRequest_Reason&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetRequest_Reason& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetRequest_Reason* internal_default_instance() {
    return reinterpret_cast<const ResetRequest_Reason*>(
               &_ResetRequest_Reason_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ResetRequest_Reason& a, ResetRequest_Reason& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetRequest_Reason* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetRequest_Reason* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetRequest_Reason* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetRequest_Reason>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResetRequest_Reason& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResetRequest_Reason& from) {
    ResetRequest_Reason::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetRequest_Reason* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uprotocol.core.usubscription.v3.ResetRequest.Reason";
  }
  protected:
  explicit ResetRequest_Reason(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResetRequest_Reason_Code Code;
  static constexpr Code UNSPECIFIED =
    ResetRequest_Reason_Code_UNSPECIFIED;
  static constexpr Code FACTORY_RESET =
    ResetRequest_Reason_Code_FACTORY_RESET;
  static constexpr Code CORRUPTED_DATA =
    ResetRequest_Reason_Code_CORRUPTED_DATA;
  static inline bool Code_IsValid(int value) {
    return ResetRequest_Reason_Code_IsValid(value);
  }
  static constexpr Code Code_MIN =
    ResetRequest_Reason_Code_Code_MIN;
  static constexpr Code Code_MAX =
    ResetRequest_Reason_Code_Code_MAX;
  static constexpr int Code_ARRAYSIZE =
    ResetRequest_Reason_Code_Code_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Code_descriptor() {
    return ResetRequest_Reason_Code_descriptor();
  }
  template<typename T>
  static inline const std::string& Code_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Code>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Code_Name.");
    return ResetRequest_Reason_Code_Name(enum_t_value);
  }
  static inline bool Code_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Code* value) {
    return ResetRequest_Reason_Code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // optional string message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .uprotocol.core.usubscription.v3.ResetRequest.Reason.Code code = 1;
  void clear_code();
  ::uprotocol::core::usubscription::v3::ResetRequest_Reason_Code code() const;
  void set_code(::uprotocol::core::usubscription::v3::ResetRequest_Reason_Code value);
  private:
  ::uprotocol::core::usubscription::v3::ResetRequest_Reason_Code _internal_code() const;
  void _internal_set_code(::uprotocol::core::usubscription::v3::ResetRequest_Reason_Code value);
  public:

  // @@protoc_insertion_point(class_scope:uprotocol.core.usubscription.v3.ResetRequest.Reason)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2fusubscription_2fv3_2fusubscription_2eproto;
};
// -------------------------------------------------------------------

class ResetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:uprotocol.core.usubscription.v3.ResetRequest) */ {
 public:
  inline ResetRequest() : ResetRequest(nullptr) {}
  ~ResetRequest() override;
  explicit PROTOBUF_CONSTEXPR ResetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetRequest(const ResetRequest& from);
  ResetRequest(ResetRequest&& from) noexcept
    : ResetRequest() {
    *this = ::std::move(from);
  }

  inline ResetRequest& operator=(const ResetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetRequest& operator=(ResetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetRequest* internal_default_instance() {
    return reinterpret_cast<const ResetRequest*>(
               &_ResetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ResetRequest& a, ResetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResetRequest& from) {
    ResetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "uprotocol.core.usubscription.v3.ResetRequest";
  }
  protected:
  explicit ResetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResetRequest_Reason Reason;

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 1,
    kBeforeFieldNumber = 2,
  };
  // optional .uprotocol.core.usubscription.v3.ResetRequest.Reason reason = 1;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  const ::uprotocol::core::usubscription::v3::ResetRequest_Reason& reason() const;
  PROTOBUF_NODISCARD ::uprotocol::core::usubscription::v3::ResetRequest_Reason* release_reason();
  ::uprotocol::core::usubscription::v3::ResetRequest_Reason* mutable_reason();
  void set_allocated_reason(::uprotocol::core::usubscription::v3::ResetRequest_Reason* reason);
  private:
  const ::uprotocol::core::usubscription::v3::ResetRequest_Reason& _internal_reason() const;
  ::uprotocol::core::usubscription::v3::ResetRequest_Reason* _internal_mutable_reason();
  public:
  void unsafe_arena_set_allocated_reason(
      ::uprotocol::core::usubscription::v3::ResetRequest_Reason* reason);
  ::uprotocol::core::usubscription::v3::ResetRequest_Reason* unsafe_arena_release_reason();

  // optional .google.protobuf.Timestamp before = 2;
  bool has_before() const;
  private:
  bool _internal_has_before() const;
  public:
  void clear_before();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& before() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_before();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_before();
  void set_allocated_before(::PROTOBUF_NAMESPACE_ID::Timestamp* before);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_before() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_before();
  public:
  void unsafe_arena_set_allocated_before(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* before);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_before();

  // @@protoc_insertion_point(class_scope:uprotocol.core.usubscription.v3.ResetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uprotocol::core::usubscription::v3::ResetRequest_Reason* reason_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* before_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2fusubscription_2fv3_2fusubscription_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SubscribeAttributes

// .google.protobuf.Timestamp expire = 1;
inline bool SubscribeAttributes::_internal_has_expire() const {
  return this != internal_default_instance() && _impl_.expire_ != nullptr;
}
inline bool SubscribeAttributes::has_expire() const {
  return _internal_has_expire();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SubscribeAttributes::_internal_expire() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.expire_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SubscribeAttributes::expire() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.SubscribeAttributes.expire)
  return _internal_expire();
}
inline void SubscribeAttributes::unsafe_arena_set_allocated_expire(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* expire) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expire_);
  }
  _impl_.expire_ = expire;
  if (expire) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.SubscribeAttributes.expire)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SubscribeAttributes::release_expire() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.expire_;
  _impl_.expire_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SubscribeAttributes::unsafe_arena_release_expire() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.SubscribeAttributes.expire)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.expire_;
  _impl_.expire_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SubscribeAttributes::_internal_mutable_expire() {
  
  if (_impl_.expire_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.expire_ = p;
  }
  return _impl_.expire_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SubscribeAttributes::mutable_expire() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_expire();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.SubscribeAttributes.expire)
  return _msg;
}
inline void SubscribeAttributes::set_allocated_expire(::PROTOBUF_NAMESPACE_ID::Timestamp* expire) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expire_);
  }
  if (expire) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expire));
    if (message_arena != submessage_arena) {
      expire = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expire, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.expire_ = expire;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.SubscribeAttributes.expire)
}

// repeated .google.protobuf.Any details = 2;
inline int SubscribeAttributes::_internal_details_size() const {
  return _impl_.details_.size();
}
inline int SubscribeAttributes::details_size() const {
  return _internal_details_size();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* SubscribeAttributes::mutable_details(int index) {
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.SubscribeAttributes.details)
  return _impl_.details_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
SubscribeAttributes::mutable_details() {
  // @@protoc_insertion_point(field_mutable_list:uprotocol.core.usubscription.v3.SubscribeAttributes.details)
  return &_impl_.details_;
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& SubscribeAttributes::_internal_details(int index) const {
  return _impl_.details_.Get(index);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& SubscribeAttributes::details(int index) const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.SubscribeAttributes.details)
  return _internal_details(index);
}
inline ::PROTOBUF_NAMESPACE_ID::Any* SubscribeAttributes::_internal_add_details() {
  return _impl_.details_.Add();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* SubscribeAttributes::add_details() {
  ::PROTOBUF_NAMESPACE_ID::Any* _add = _internal_add_details();
  // @@protoc_insertion_point(field_add:uprotocol.core.usubscription.v3.SubscribeAttributes.details)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
SubscribeAttributes::details() const {
  // @@protoc_insertion_point(field_list:uprotocol.core.usubscription.v3.SubscribeAttributes.details)
  return _impl_.details_;
}

// -------------------------------------------------------------------

// SubscriberInfo

// .uprotocol.v1.UUri uri = 1;
inline bool SubscriberInfo::_internal_has_uri() const {
  return this != internal_default_instance() && _impl_.uri_ != nullptr;
}
inline bool SubscriberInfo::has_uri() const {
  return _internal_has_uri();
}
inline const ::uprotocol::v1::UUri& SubscriberInfo::_internal_uri() const {
  const ::uprotocol::v1::UUri* p = _impl_.uri_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::v1::UUri&>(
      ::uprotocol::v1::_UUri_default_instance_);
}
inline const ::uprotocol::v1::UUri& SubscriberInfo::uri() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.SubscriberInfo.uri)
  return _internal_uri();
}
inline void SubscriberInfo::unsafe_arena_set_allocated_uri(
    ::uprotocol::v1::UUri* uri) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uri_);
  }
  _impl_.uri_ = uri;
  if (uri) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.SubscriberInfo.uri)
}
inline ::uprotocol::v1::UUri* SubscriberInfo::release_uri() {
  
  ::uprotocol::v1::UUri* temp = _impl_.uri_;
  _impl_.uri_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::v1::UUri* SubscriberInfo::unsafe_arena_release_uri() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.SubscriberInfo.uri)
  
  ::uprotocol::v1::UUri* temp = _impl_.uri_;
  _impl_.uri_ = nullptr;
  return temp;
}
inline ::uprotocol::v1::UUri* SubscriberInfo::_internal_mutable_uri() {
  
  if (_impl_.uri_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::v1::UUri>(GetArenaForAllocation());
    _impl_.uri_ = p;
  }
  return _impl_.uri_;
}
inline ::uprotocol::v1::UUri* SubscriberInfo::mutable_uri() {
  ::uprotocol::v1::UUri* _msg = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.SubscriberInfo.uri)
  return _msg;
}
inline void SubscriberInfo::set_allocated_uri(::uprotocol::v1::UUri* uri) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uri_);
  }
  if (uri) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(uri));
    if (message_arena != submessage_arena) {
      uri = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uri, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.uri_ = uri;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.SubscriberInfo.uri)
}

// repeated .google.protobuf.Any details = 2;
inline int SubscriberInfo::_internal_details_size() const {
  return _impl_.details_.size();
}
inline int SubscriberInfo::details_size() const {
  return _internal_details_size();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* SubscriberInfo::mutable_details(int index) {
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.SubscriberInfo.details)
  return _impl_.details_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
SubscriberInfo::mutable_details() {
  // @@protoc_insertion_point(field_mutable_list:uprotocol.core.usubscription.v3.SubscriberInfo.details)
  return &_impl_.details_;
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& SubscriberInfo::_internal_details(int index) const {
  return _impl_.details_.Get(index);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& SubscriberInfo::details(int index) const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.SubscriberInfo.details)
  return _internal_details(index);
}
inline ::PROTOBUF_NAMESPACE_ID::Any* SubscriberInfo::_internal_add_details() {
  return _impl_.details_.Add();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* SubscriberInfo::add_details() {
  ::PROTOBUF_NAMESPACE_ID::Any* _add = _internal_add_details();
  // @@protoc_insertion_point(field_add:uprotocol.core.usubscription.v3.SubscriberInfo.details)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
SubscriberInfo::details() const {
  // @@protoc_insertion_point(field_list:uprotocol.core.usubscription.v3.SubscriberInfo.details)
  return _impl_.details_;
}

// -------------------------------------------------------------------

// SubscriptionStatus

// .uprotocol.core.usubscription.v3.SubscriptionStatus.State state = 1;
inline void SubscriptionStatus::clear_state() {
  _impl_.state_ = 0;
}
inline ::uprotocol::core::usubscription::v3::SubscriptionStatus_State SubscriptionStatus::_internal_state() const {
  return static_cast< ::uprotocol::core::usubscription::v3::SubscriptionStatus_State >(_impl_.state_);
}
inline ::uprotocol::core::usubscription::v3::SubscriptionStatus_State SubscriptionStatus::state() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.SubscriptionStatus.state)
  return _internal_state();
}
inline void SubscriptionStatus::_internal_set_state(::uprotocol::core::usubscription::v3::SubscriptionStatus_State value) {
  
  _impl_.state_ = value;
}
inline void SubscriptionStatus::set_state(::uprotocol::core::usubscription::v3::SubscriptionStatus_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:uprotocol.core.usubscription.v3.SubscriptionStatus.state)
}

// .uprotocol.v1.UCode code = 2;
inline void SubscriptionStatus::clear_code() {
  _impl_.code_ = 0;
}
inline ::uprotocol::v1::UCode SubscriptionStatus::_internal_code() const {
  return static_cast< ::uprotocol::v1::UCode >(_impl_.code_);
}
inline ::uprotocol::v1::UCode SubscriptionStatus::code() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.SubscriptionStatus.code)
  return _internal_code();
}
inline void SubscriptionStatus::_internal_set_code(::uprotocol::v1::UCode value) {
  
  _impl_.code_ = value;
}
inline void SubscriptionStatus::set_code(::uprotocol::v1::UCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:uprotocol.core.usubscription.v3.SubscriptionStatus.code)
}

// string message = 3;
inline void SubscriptionStatus::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& SubscriptionStatus::message() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.SubscriptionStatus.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscriptionStatus::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uprotocol.core.usubscription.v3.SubscriptionStatus.message)
}
inline std::string* SubscriptionStatus::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.SubscriptionStatus.message)
  return _s;
}
inline const std::string& SubscriptionStatus::_internal_message() const {
  return _impl_.message_.Get();
}
inline void SubscriptionStatus::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscriptionStatus::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* SubscriptionStatus::release_message() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.SubscriptionStatus.message)
  return _impl_.message_.Release();
}
inline void SubscriptionStatus::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.SubscriptionStatus.message)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// EventDeliveryConfig

// string id = 1;
inline void EventDeliveryConfig::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& EventDeliveryConfig::id() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.EventDeliveryConfig.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventDeliveryConfig::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uprotocol.core.usubscription.v3.EventDeliveryConfig.id)
}
inline std::string* EventDeliveryConfig::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.EventDeliveryConfig.id)
  return _s;
}
inline const std::string& EventDeliveryConfig::_internal_id() const {
  return _impl_.id_.Get();
}
inline void EventDeliveryConfig::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* EventDeliveryConfig::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* EventDeliveryConfig::release_id() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.EventDeliveryConfig.id)
  return _impl_.id_.Release();
}
inline void EventDeliveryConfig::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.EventDeliveryConfig.id)
}

// string type = 2;
inline void EventDeliveryConfig::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& EventDeliveryConfig::type() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.EventDeliveryConfig.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventDeliveryConfig::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uprotocol.core.usubscription.v3.EventDeliveryConfig.type)
}
inline std::string* EventDeliveryConfig::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.EventDeliveryConfig.type)
  return _s;
}
inline const std::string& EventDeliveryConfig::_internal_type() const {
  return _impl_.type_.Get();
}
inline void EventDeliveryConfig::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* EventDeliveryConfig::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* EventDeliveryConfig::release_type() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.EventDeliveryConfig.type)
  return _impl_.type_.Release();
}
inline void EventDeliveryConfig::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.EventDeliveryConfig.type)
}

// map<string, .google.protobuf.Any> attributes = 3;
inline int EventDeliveryConfig::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int EventDeliveryConfig::attributes_size() const {
  return _internal_attributes_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
EventDeliveryConfig::_internal_attributes() const {
  return _impl_.attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
EventDeliveryConfig::attributes() const {
  // @@protoc_insertion_point(field_map:uprotocol.core.usubscription.v3.EventDeliveryConfig.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
EventDeliveryConfig::_internal_mutable_attributes() {
  return _impl_.attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
EventDeliveryConfig::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:uprotocol.core.usubscription.v3.EventDeliveryConfig.attributes)
  return _internal_mutable_attributes();
}

// -------------------------------------------------------------------

// SubscriptionRequest

// .uprotocol.v1.UUri topic = 1;
inline bool SubscriptionRequest::_internal_has_topic() const {
  return this != internal_default_instance() && _impl_.topic_ != nullptr;
}
inline bool SubscriptionRequest::has_topic() const {
  return _internal_has_topic();
}
inline const ::uprotocol::v1::UUri& SubscriptionRequest::_internal_topic() const {
  const ::uprotocol::v1::UUri* p = _impl_.topic_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::v1::UUri&>(
      ::uprotocol::v1::_UUri_default_instance_);
}
inline const ::uprotocol::v1::UUri& SubscriptionRequest::topic() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.SubscriptionRequest.topic)
  return _internal_topic();
}
inline void SubscriptionRequest::unsafe_arena_set_allocated_topic(
    ::uprotocol::v1::UUri* topic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.topic_);
  }
  _impl_.topic_ = topic;
  if (topic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.SubscriptionRequest.topic)
}
inline ::uprotocol::v1::UUri* SubscriptionRequest::release_topic() {
  
  ::uprotocol::v1::UUri* temp = _impl_.topic_;
  _impl_.topic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::v1::UUri* SubscriptionRequest::unsafe_arena_release_topic() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.SubscriptionRequest.topic)
  
  ::uprotocol::v1::UUri* temp = _impl_.topic_;
  _impl_.topic_ = nullptr;
  return temp;
}
inline ::uprotocol::v1::UUri* SubscriptionRequest::_internal_mutable_topic() {
  
  if (_impl_.topic_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::v1::UUri>(GetArenaForAllocation());
    _impl_.topic_ = p;
  }
  return _impl_.topic_;
}
inline ::uprotocol::v1::UUri* SubscriptionRequest::mutable_topic() {
  ::uprotocol::v1::UUri* _msg = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.SubscriptionRequest.topic)
  return _msg;
}
inline void SubscriptionRequest::set_allocated_topic(::uprotocol::v1::UUri* topic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.topic_);
  }
  if (topic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic));
    if (message_arena != submessage_arena) {
      topic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topic, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.topic_ = topic;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.SubscriptionRequest.topic)
}

// .uprotocol.core.usubscription.v3.SubscriberInfo subscriber = 2;
inline bool SubscriptionRequest::_internal_has_subscriber() const {
  return this != internal_default_instance() && _impl_.subscriber_ != nullptr;
}
inline bool SubscriptionRequest::has_subscriber() const {
  return _internal_has_subscriber();
}
inline void SubscriptionRequest::clear_subscriber() {
  if (GetArenaForAllocation() == nullptr && _impl_.subscriber_ != nullptr) {
    delete _impl_.subscriber_;
  }
  _impl_.subscriber_ = nullptr;
}
inline const ::uprotocol::core::usubscription::v3::SubscriberInfo& SubscriptionRequest::_internal_subscriber() const {
  const ::uprotocol::core::usubscription::v3::SubscriberInfo* p = _impl_.subscriber_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::core::usubscription::v3::SubscriberInfo&>(
      ::uprotocol::core::usubscription::v3::_SubscriberInfo_default_instance_);
}
inline const ::uprotocol::core::usubscription::v3::SubscriberInfo& SubscriptionRequest::subscriber() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.SubscriptionRequest.subscriber)
  return _internal_subscriber();
}
inline void SubscriptionRequest::unsafe_arena_set_allocated_subscriber(
    ::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subscriber_);
  }
  _impl_.subscriber_ = subscriber;
  if (subscriber) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.SubscriptionRequest.subscriber)
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* SubscriptionRequest::release_subscriber() {
  
  ::uprotocol::core::usubscription::v3::SubscriberInfo* temp = _impl_.subscriber_;
  _impl_.subscriber_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* SubscriptionRequest::unsafe_arena_release_subscriber() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.SubscriptionRequest.subscriber)
  
  ::uprotocol::core::usubscription::v3::SubscriberInfo* temp = _impl_.subscriber_;
  _impl_.subscriber_ = nullptr;
  return temp;
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* SubscriptionRequest::_internal_mutable_subscriber() {
  
  if (_impl_.subscriber_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::core::usubscription::v3::SubscriberInfo>(GetArenaForAllocation());
    _impl_.subscriber_ = p;
  }
  return _impl_.subscriber_;
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* SubscriptionRequest::mutable_subscriber() {
  ::uprotocol::core::usubscription::v3::SubscriberInfo* _msg = _internal_mutable_subscriber();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.SubscriptionRequest.subscriber)
  return _msg;
}
inline void SubscriptionRequest::set_allocated_subscriber(::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.subscriber_;
  }
  if (subscriber) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(subscriber);
    if (message_arena != submessage_arena) {
      subscriber = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscriber, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.subscriber_ = subscriber;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.SubscriptionRequest.subscriber)
}

// .uprotocol.core.usubscription.v3.SubscribeAttributes attributes = 3;
inline bool SubscriptionRequest::_internal_has_attributes() const {
  return this != internal_default_instance() && _impl_.attributes_ != nullptr;
}
inline bool SubscriptionRequest::has_attributes() const {
  return _internal_has_attributes();
}
inline void SubscriptionRequest::clear_attributes() {
  if (GetArenaForAllocation() == nullptr && _impl_.attributes_ != nullptr) {
    delete _impl_.attributes_;
  }
  _impl_.attributes_ = nullptr;
}
inline const ::uprotocol::core::usubscription::v3::SubscribeAttributes& SubscriptionRequest::_internal_attributes() const {
  const ::uprotocol::core::usubscription::v3::SubscribeAttributes* p = _impl_.attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::core::usubscription::v3::SubscribeAttributes&>(
      ::uprotocol::core::usubscription::v3::_SubscribeAttributes_default_instance_);
}
inline const ::uprotocol::core::usubscription::v3::SubscribeAttributes& SubscriptionRequest::attributes() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.SubscriptionRequest.attributes)
  return _internal_attributes();
}
inline void SubscriptionRequest::unsafe_arena_set_allocated_attributes(
    ::uprotocol::core::usubscription::v3::SubscribeAttributes* attributes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attributes_);
  }
  _impl_.attributes_ = attributes;
  if (attributes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.SubscriptionRequest.attributes)
}
inline ::uprotocol::core::usubscription::v3::SubscribeAttributes* SubscriptionRequest::release_attributes() {
  
  ::uprotocol::core::usubscription::v3::SubscribeAttributes* temp = _impl_.attributes_;
  _impl_.attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::core::usubscription::v3::SubscribeAttributes* SubscriptionRequest::unsafe_arena_release_attributes() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.SubscriptionRequest.attributes)
  
  ::uprotocol::core::usubscription::v3::SubscribeAttributes* temp = _impl_.attributes_;
  _impl_.attributes_ = nullptr;
  return temp;
}
inline ::uprotocol::core::usubscription::v3::SubscribeAttributes* SubscriptionRequest::_internal_mutable_attributes() {
  
  if (_impl_.attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::core::usubscription::v3::SubscribeAttributes>(GetArenaForAllocation());
    _impl_.attributes_ = p;
  }
  return _impl_.attributes_;
}
inline ::uprotocol::core::usubscription::v3::SubscribeAttributes* SubscriptionRequest::mutable_attributes() {
  ::uprotocol::core::usubscription::v3::SubscribeAttributes* _msg = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.SubscriptionRequest.attributes)
  return _msg;
}
inline void SubscriptionRequest::set_allocated_attributes(::uprotocol::core::usubscription::v3::SubscribeAttributes* attributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.attributes_;
  }
  if (attributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attributes);
    if (message_arena != submessage_arena) {
      attributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attributes, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.attributes_ = attributes;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.SubscriptionRequest.attributes)
}

// -------------------------------------------------------------------

// SubscriptionResponse

// .uprotocol.core.usubscription.v3.SubscriptionStatus status = 1;
inline bool SubscriptionResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool SubscriptionResponse::has_status() const {
  return _internal_has_status();
}
inline void SubscriptionResponse::clear_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
}
inline const ::uprotocol::core::usubscription::v3::SubscriptionStatus& SubscriptionResponse::_internal_status() const {
  const ::uprotocol::core::usubscription::v3::SubscriptionStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::core::usubscription::v3::SubscriptionStatus&>(
      ::uprotocol::core::usubscription::v3::_SubscriptionStatus_default_instance_);
}
inline const ::uprotocol::core::usubscription::v3::SubscriptionStatus& SubscriptionResponse::status() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.SubscriptionResponse.status)
  return _internal_status();
}
inline void SubscriptionResponse::unsafe_arena_set_allocated_status(
    ::uprotocol::core::usubscription::v3::SubscriptionStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.SubscriptionResponse.status)
}
inline ::uprotocol::core::usubscription::v3::SubscriptionStatus* SubscriptionResponse::release_status() {
  
  ::uprotocol::core::usubscription::v3::SubscriptionStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::core::usubscription::v3::SubscriptionStatus* SubscriptionResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.SubscriptionResponse.status)
  
  ::uprotocol::core::usubscription::v3::SubscriptionStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::uprotocol::core::usubscription::v3::SubscriptionStatus* SubscriptionResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::core::usubscription::v3::SubscriptionStatus>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::uprotocol::core::usubscription::v3::SubscriptionStatus* SubscriptionResponse::mutable_status() {
  ::uprotocol::core::usubscription::v3::SubscriptionStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.SubscriptionResponse.status)
  return _msg;
}
inline void SubscriptionResponse::set_allocated_status(::uprotocol::core::usubscription::v3::SubscriptionStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.SubscriptionResponse.status)
}

// .uprotocol.core.usubscription.v3.EventDeliveryConfig config = 2;
inline bool SubscriptionResponse::_internal_has_config() const {
  return this != internal_default_instance() && _impl_.config_ != nullptr;
}
inline bool SubscriptionResponse::has_config() const {
  return _internal_has_config();
}
inline void SubscriptionResponse::clear_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.config_ != nullptr) {
    delete _impl_.config_;
  }
  _impl_.config_ = nullptr;
}
inline const ::uprotocol::core::usubscription::v3::EventDeliveryConfig& SubscriptionResponse::_internal_config() const {
  const ::uprotocol::core::usubscription::v3::EventDeliveryConfig* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::core::usubscription::v3::EventDeliveryConfig&>(
      ::uprotocol::core::usubscription::v3::_EventDeliveryConfig_default_instance_);
}
inline const ::uprotocol::core::usubscription::v3::EventDeliveryConfig& SubscriptionResponse::config() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.SubscriptionResponse.config)
  return _internal_config();
}
inline void SubscriptionResponse::unsafe_arena_set_allocated_config(
    ::uprotocol::core::usubscription::v3::EventDeliveryConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.SubscriptionResponse.config)
}
inline ::uprotocol::core::usubscription::v3::EventDeliveryConfig* SubscriptionResponse::release_config() {
  
  ::uprotocol::core::usubscription::v3::EventDeliveryConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::core::usubscription::v3::EventDeliveryConfig* SubscriptionResponse::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.SubscriptionResponse.config)
  
  ::uprotocol::core::usubscription::v3::EventDeliveryConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::uprotocol::core::usubscription::v3::EventDeliveryConfig* SubscriptionResponse::_internal_mutable_config() {
  
  if (_impl_.config_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::core::usubscription::v3::EventDeliveryConfig>(GetArenaForAllocation());
    _impl_.config_ = p;
  }
  return _impl_.config_;
}
inline ::uprotocol::core::usubscription::v3::EventDeliveryConfig* SubscriptionResponse::mutable_config() {
  ::uprotocol::core::usubscription::v3::EventDeliveryConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.SubscriptionResponse.config)
  return _msg;
}
inline void SubscriptionResponse::set_allocated_config(::uprotocol::core::usubscription::v3::EventDeliveryConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.config_ = config;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.SubscriptionResponse.config)
}

// .uprotocol.v1.UUri topic = 3;
inline bool SubscriptionResponse::_internal_has_topic() const {
  return this != internal_default_instance() && _impl_.topic_ != nullptr;
}
inline bool SubscriptionResponse::has_topic() const {
  return _internal_has_topic();
}
inline const ::uprotocol::v1::UUri& SubscriptionResponse::_internal_topic() const {
  const ::uprotocol::v1::UUri* p = _impl_.topic_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::v1::UUri&>(
      ::uprotocol::v1::_UUri_default_instance_);
}
inline const ::uprotocol::v1::UUri& SubscriptionResponse::topic() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.SubscriptionResponse.topic)
  return _internal_topic();
}
inline void SubscriptionResponse::unsafe_arena_set_allocated_topic(
    ::uprotocol::v1::UUri* topic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.topic_);
  }
  _impl_.topic_ = topic;
  if (topic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.SubscriptionResponse.topic)
}
inline ::uprotocol::v1::UUri* SubscriptionResponse::release_topic() {
  
  ::uprotocol::v1::UUri* temp = _impl_.topic_;
  _impl_.topic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::v1::UUri* SubscriptionResponse::unsafe_arena_release_topic() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.SubscriptionResponse.topic)
  
  ::uprotocol::v1::UUri* temp = _impl_.topic_;
  _impl_.topic_ = nullptr;
  return temp;
}
inline ::uprotocol::v1::UUri* SubscriptionResponse::_internal_mutable_topic() {
  
  if (_impl_.topic_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::v1::UUri>(GetArenaForAllocation());
    _impl_.topic_ = p;
  }
  return _impl_.topic_;
}
inline ::uprotocol::v1::UUri* SubscriptionResponse::mutable_topic() {
  ::uprotocol::v1::UUri* _msg = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.SubscriptionResponse.topic)
  return _msg;
}
inline void SubscriptionResponse::set_allocated_topic(::uprotocol::v1::UUri* topic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.topic_);
  }
  if (topic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic));
    if (message_arena != submessage_arena) {
      topic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topic, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.topic_ = topic;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.SubscriptionResponse.topic)
}

// -------------------------------------------------------------------

// UnsubscribeRequest

// .uprotocol.v1.UUri topic = 1;
inline bool UnsubscribeRequest::_internal_has_topic() const {
  return this != internal_default_instance() && _impl_.topic_ != nullptr;
}
inline bool UnsubscribeRequest::has_topic() const {
  return _internal_has_topic();
}
inline const ::uprotocol::v1::UUri& UnsubscribeRequest::_internal_topic() const {
  const ::uprotocol::v1::UUri* p = _impl_.topic_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::v1::UUri&>(
      ::uprotocol::v1::_UUri_default_instance_);
}
inline const ::uprotocol::v1::UUri& UnsubscribeRequest::topic() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.UnsubscribeRequest.topic)
  return _internal_topic();
}
inline void UnsubscribeRequest::unsafe_arena_set_allocated_topic(
    ::uprotocol::v1::UUri* topic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.topic_);
  }
  _impl_.topic_ = topic;
  if (topic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.UnsubscribeRequest.topic)
}
inline ::uprotocol::v1::UUri* UnsubscribeRequest::release_topic() {
  
  ::uprotocol::v1::UUri* temp = _impl_.topic_;
  _impl_.topic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::v1::UUri* UnsubscribeRequest::unsafe_arena_release_topic() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.UnsubscribeRequest.topic)
  
  ::uprotocol::v1::UUri* temp = _impl_.topic_;
  _impl_.topic_ = nullptr;
  return temp;
}
inline ::uprotocol::v1::UUri* UnsubscribeRequest::_internal_mutable_topic() {
  
  if (_impl_.topic_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::v1::UUri>(GetArenaForAllocation());
    _impl_.topic_ = p;
  }
  return _impl_.topic_;
}
inline ::uprotocol::v1::UUri* UnsubscribeRequest::mutable_topic() {
  ::uprotocol::v1::UUri* _msg = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.UnsubscribeRequest.topic)
  return _msg;
}
inline void UnsubscribeRequest::set_allocated_topic(::uprotocol::v1::UUri* topic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.topic_);
  }
  if (topic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic));
    if (message_arena != submessage_arena) {
      topic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topic, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.topic_ = topic;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.UnsubscribeRequest.topic)
}

// .uprotocol.core.usubscription.v3.SubscriberInfo subscriber = 2;
inline bool UnsubscribeRequest::_internal_has_subscriber() const {
  return this != internal_default_instance() && _impl_.subscriber_ != nullptr;
}
inline bool UnsubscribeRequest::has_subscriber() const {
  return _internal_has_subscriber();
}
inline void UnsubscribeRequest::clear_subscriber() {
  if (GetArenaForAllocation() == nullptr && _impl_.subscriber_ != nullptr) {
    delete _impl_.subscriber_;
  }
  _impl_.subscriber_ = nullptr;
}
inline const ::uprotocol::core::usubscription::v3::SubscriberInfo& UnsubscribeRequest::_internal_subscriber() const {
  const ::uprotocol::core::usubscription::v3::SubscriberInfo* p = _impl_.subscriber_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::core::usubscription::v3::SubscriberInfo&>(
      ::uprotocol::core::usubscription::v3::_SubscriberInfo_default_instance_);
}
inline const ::uprotocol::core::usubscription::v3::SubscriberInfo& UnsubscribeRequest::subscriber() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.UnsubscribeRequest.subscriber)
  return _internal_subscriber();
}
inline void UnsubscribeRequest::unsafe_arena_set_allocated_subscriber(
    ::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subscriber_);
  }
  _impl_.subscriber_ = subscriber;
  if (subscriber) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.UnsubscribeRequest.subscriber)
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* UnsubscribeRequest::release_subscriber() {
  
  ::uprotocol::core::usubscription::v3::SubscriberInfo* temp = _impl_.subscriber_;
  _impl_.subscriber_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* UnsubscribeRequest::unsafe_arena_release_subscriber() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.UnsubscribeRequest.subscriber)
  
  ::uprotocol::core::usubscription::v3::SubscriberInfo* temp = _impl_.subscriber_;
  _impl_.subscriber_ = nullptr;
  return temp;
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* UnsubscribeRequest::_internal_mutable_subscriber() {
  
  if (_impl_.subscriber_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::core::usubscription::v3::SubscriberInfo>(GetArenaForAllocation());
    _impl_.subscriber_ = p;
  }
  return _impl_.subscriber_;
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* UnsubscribeRequest::mutable_subscriber() {
  ::uprotocol::core::usubscription::v3::SubscriberInfo* _msg = _internal_mutable_subscriber();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.UnsubscribeRequest.subscriber)
  return _msg;
}
inline void UnsubscribeRequest::set_allocated_subscriber(::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.subscriber_;
  }
  if (subscriber) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(subscriber);
    if (message_arena != submessage_arena) {
      subscriber = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscriber, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.subscriber_ = subscriber;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.UnsubscribeRequest.subscriber)
}

// -------------------------------------------------------------------

// FetchSubscribersRequest

// .uprotocol.v1.UUri topic = 1;
inline bool FetchSubscribersRequest::_internal_has_topic() const {
  return this != internal_default_instance() && _impl_.topic_ != nullptr;
}
inline bool FetchSubscribersRequest::has_topic() const {
  return _internal_has_topic();
}
inline const ::uprotocol::v1::UUri& FetchSubscribersRequest::_internal_topic() const {
  const ::uprotocol::v1::UUri* p = _impl_.topic_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::v1::UUri&>(
      ::uprotocol::v1::_UUri_default_instance_);
}
inline const ::uprotocol::v1::UUri& FetchSubscribersRequest::topic() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.FetchSubscribersRequest.topic)
  return _internal_topic();
}
inline void FetchSubscribersRequest::unsafe_arena_set_allocated_topic(
    ::uprotocol::v1::UUri* topic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.topic_);
  }
  _impl_.topic_ = topic;
  if (topic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.FetchSubscribersRequest.topic)
}
inline ::uprotocol::v1::UUri* FetchSubscribersRequest::release_topic() {
  
  ::uprotocol::v1::UUri* temp = _impl_.topic_;
  _impl_.topic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::v1::UUri* FetchSubscribersRequest::unsafe_arena_release_topic() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.FetchSubscribersRequest.topic)
  
  ::uprotocol::v1::UUri* temp = _impl_.topic_;
  _impl_.topic_ = nullptr;
  return temp;
}
inline ::uprotocol::v1::UUri* FetchSubscribersRequest::_internal_mutable_topic() {
  
  if (_impl_.topic_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::v1::UUri>(GetArenaForAllocation());
    _impl_.topic_ = p;
  }
  return _impl_.topic_;
}
inline ::uprotocol::v1::UUri* FetchSubscribersRequest::mutable_topic() {
  ::uprotocol::v1::UUri* _msg = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.FetchSubscribersRequest.topic)
  return _msg;
}
inline void FetchSubscribersRequest::set_allocated_topic(::uprotocol::v1::UUri* topic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.topic_);
  }
  if (topic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic));
    if (message_arena != submessage_arena) {
      topic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topic, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.topic_ = topic;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.FetchSubscribersRequest.topic)
}

// optional uint32 offset = 2;
inline bool FetchSubscribersRequest::_internal_has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FetchSubscribersRequest::has_offset() const {
  return _internal_has_offset();
}
inline void FetchSubscribersRequest::clear_offset() {
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t FetchSubscribersRequest::_internal_offset() const {
  return _impl_.offset_;
}
inline uint32_t FetchSubscribersRequest::offset() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.FetchSubscribersRequest.offset)
  return _internal_offset();
}
inline void FetchSubscribersRequest::_internal_set_offset(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.offset_ = value;
}
inline void FetchSubscribersRequest::set_offset(uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:uprotocol.core.usubscription.v3.FetchSubscribersRequest.offset)
}

// -------------------------------------------------------------------

// FetchSubscribersResponse

// repeated .uprotocol.core.usubscription.v3.SubscriberInfo subscribers = 1;
inline int FetchSubscribersResponse::_internal_subscribers_size() const {
  return _impl_.subscribers_.size();
}
inline int FetchSubscribersResponse::subscribers_size() const {
  return _internal_subscribers_size();
}
inline void FetchSubscribersResponse::clear_subscribers() {
  _impl_.subscribers_.Clear();
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* FetchSubscribersResponse::mutable_subscribers(int index) {
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.FetchSubscribersResponse.subscribers)
  return _impl_.subscribers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uprotocol::core::usubscription::v3::SubscriberInfo >*
FetchSubscribersResponse::mutable_subscribers() {
  // @@protoc_insertion_point(field_mutable_list:uprotocol.core.usubscription.v3.FetchSubscribersResponse.subscribers)
  return &_impl_.subscribers_;
}
inline const ::uprotocol::core::usubscription::v3::SubscriberInfo& FetchSubscribersResponse::_internal_subscribers(int index) const {
  return _impl_.subscribers_.Get(index);
}
inline const ::uprotocol::core::usubscription::v3::SubscriberInfo& FetchSubscribersResponse::subscribers(int index) const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.FetchSubscribersResponse.subscribers)
  return _internal_subscribers(index);
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* FetchSubscribersResponse::_internal_add_subscribers() {
  return _impl_.subscribers_.Add();
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* FetchSubscribersResponse::add_subscribers() {
  ::uprotocol::core::usubscription::v3::SubscriberInfo* _add = _internal_add_subscribers();
  // @@protoc_insertion_point(field_add:uprotocol.core.usubscription.v3.FetchSubscribersResponse.subscribers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uprotocol::core::usubscription::v3::SubscriberInfo >&
FetchSubscribersResponse::subscribers() const {
  // @@protoc_insertion_point(field_list:uprotocol.core.usubscription.v3.FetchSubscribersResponse.subscribers)
  return _impl_.subscribers_;
}

// optional bool has_more_records = 2;
inline bool FetchSubscribersResponse::_internal_has_has_more_records() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FetchSubscribersResponse::has_has_more_records() const {
  return _internal_has_has_more_records();
}
inline void FetchSubscribersResponse::clear_has_more_records() {
  _impl_.has_more_records_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool FetchSubscribersResponse::_internal_has_more_records() const {
  return _impl_.has_more_records_;
}
inline bool FetchSubscribersResponse::has_more_records() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.FetchSubscribersResponse.has_more_records)
  return _internal_has_more_records();
}
inline void FetchSubscribersResponse::_internal_set_has_more_records(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.has_more_records_ = value;
}
inline void FetchSubscribersResponse::set_has_more_records(bool value) {
  _internal_set_has_more_records(value);
  // @@protoc_insertion_point(field_set:uprotocol.core.usubscription.v3.FetchSubscribersResponse.has_more_records)
}

// .uprotocol.v1.UStatus status = 3;
inline bool FetchSubscribersResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool FetchSubscribersResponse::has_status() const {
  return _internal_has_status();
}
inline const ::uprotocol::v1::UStatus& FetchSubscribersResponse::_internal_status() const {
  const ::uprotocol::v1::UStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::v1::UStatus&>(
      ::uprotocol::v1::_UStatus_default_instance_);
}
inline const ::uprotocol::v1::UStatus& FetchSubscribersResponse::status() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.FetchSubscribersResponse.status)
  return _internal_status();
}
inline void FetchSubscribersResponse::unsafe_arena_set_allocated_status(
    ::uprotocol::v1::UStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.FetchSubscribersResponse.status)
}
inline ::uprotocol::v1::UStatus* FetchSubscribersResponse::release_status() {
  
  ::uprotocol::v1::UStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::v1::UStatus* FetchSubscribersResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.FetchSubscribersResponse.status)
  
  ::uprotocol::v1::UStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::uprotocol::v1::UStatus* FetchSubscribersResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::v1::UStatus>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::uprotocol::v1::UStatus* FetchSubscribersResponse::mutable_status() {
  ::uprotocol::v1::UStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.FetchSubscribersResponse.status)
  return _msg;
}
inline void FetchSubscribersResponse::set_allocated_status(::uprotocol::v1::UStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.FetchSubscribersResponse.status)
}

// -------------------------------------------------------------------

// Subscription

// .uprotocol.v1.UUri topic = 1;
inline bool Subscription::_internal_has_topic() const {
  return this != internal_default_instance() && _impl_.topic_ != nullptr;
}
inline bool Subscription::has_topic() const {
  return _internal_has_topic();
}
inline const ::uprotocol::v1::UUri& Subscription::_internal_topic() const {
  const ::uprotocol::v1::UUri* p = _impl_.topic_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::v1::UUri&>(
      ::uprotocol::v1::_UUri_default_instance_);
}
inline const ::uprotocol::v1::UUri& Subscription::topic() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.Subscription.topic)
  return _internal_topic();
}
inline void Subscription::unsafe_arena_set_allocated_topic(
    ::uprotocol::v1::UUri* topic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.topic_);
  }
  _impl_.topic_ = topic;
  if (topic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.Subscription.topic)
}
inline ::uprotocol::v1::UUri* Subscription::release_topic() {
  
  ::uprotocol::v1::UUri* temp = _impl_.topic_;
  _impl_.topic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::v1::UUri* Subscription::unsafe_arena_release_topic() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.Subscription.topic)
  
  ::uprotocol::v1::UUri* temp = _impl_.topic_;
  _impl_.topic_ = nullptr;
  return temp;
}
inline ::uprotocol::v1::UUri* Subscription::_internal_mutable_topic() {
  
  if (_impl_.topic_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::v1::UUri>(GetArenaForAllocation());
    _impl_.topic_ = p;
  }
  return _impl_.topic_;
}
inline ::uprotocol::v1::UUri* Subscription::mutable_topic() {
  ::uprotocol::v1::UUri* _msg = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.Subscription.topic)
  return _msg;
}
inline void Subscription::set_allocated_topic(::uprotocol::v1::UUri* topic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.topic_);
  }
  if (topic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic));
    if (message_arena != submessage_arena) {
      topic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topic, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.topic_ = topic;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.Subscription.topic)
}

// .uprotocol.core.usubscription.v3.SubscriberInfo subscriber = 2;
inline bool Subscription::_internal_has_subscriber() const {
  return this != internal_default_instance() && _impl_.subscriber_ != nullptr;
}
inline bool Subscription::has_subscriber() const {
  return _internal_has_subscriber();
}
inline void Subscription::clear_subscriber() {
  if (GetArenaForAllocation() == nullptr && _impl_.subscriber_ != nullptr) {
    delete _impl_.subscriber_;
  }
  _impl_.subscriber_ = nullptr;
}
inline const ::uprotocol::core::usubscription::v3::SubscriberInfo& Subscription::_internal_subscriber() const {
  const ::uprotocol::core::usubscription::v3::SubscriberInfo* p = _impl_.subscriber_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::core::usubscription::v3::SubscriberInfo&>(
      ::uprotocol::core::usubscription::v3::_SubscriberInfo_default_instance_);
}
inline const ::uprotocol::core::usubscription::v3::SubscriberInfo& Subscription::subscriber() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.Subscription.subscriber)
  return _internal_subscriber();
}
inline void Subscription::unsafe_arena_set_allocated_subscriber(
    ::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subscriber_);
  }
  _impl_.subscriber_ = subscriber;
  if (subscriber) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.Subscription.subscriber)
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* Subscription::release_subscriber() {
  
  ::uprotocol::core::usubscription::v3::SubscriberInfo* temp = _impl_.subscriber_;
  _impl_.subscriber_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* Subscription::unsafe_arena_release_subscriber() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.Subscription.subscriber)
  
  ::uprotocol::core::usubscription::v3::SubscriberInfo* temp = _impl_.subscriber_;
  _impl_.subscriber_ = nullptr;
  return temp;
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* Subscription::_internal_mutable_subscriber() {
  
  if (_impl_.subscriber_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::core::usubscription::v3::SubscriberInfo>(GetArenaForAllocation());
    _impl_.subscriber_ = p;
  }
  return _impl_.subscriber_;
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* Subscription::mutable_subscriber() {
  ::uprotocol::core::usubscription::v3::SubscriberInfo* _msg = _internal_mutable_subscriber();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.Subscription.subscriber)
  return _msg;
}
inline void Subscription::set_allocated_subscriber(::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.subscriber_;
  }
  if (subscriber) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(subscriber);
    if (message_arena != submessage_arena) {
      subscriber = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscriber, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.subscriber_ = subscriber;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.Subscription.subscriber)
}

// .uprotocol.core.usubscription.v3.SubscriptionStatus status = 3;
inline bool Subscription::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool Subscription::has_status() const {
  return _internal_has_status();
}
inline void Subscription::clear_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
}
inline const ::uprotocol::core::usubscription::v3::SubscriptionStatus& Subscription::_internal_status() const {
  const ::uprotocol::core::usubscription::v3::SubscriptionStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::core::usubscription::v3::SubscriptionStatus&>(
      ::uprotocol::core::usubscription::v3::_SubscriptionStatus_default_instance_);
}
inline const ::uprotocol::core::usubscription::v3::SubscriptionStatus& Subscription::status() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.Subscription.status)
  return _internal_status();
}
inline void Subscription::unsafe_arena_set_allocated_status(
    ::uprotocol::core::usubscription::v3::SubscriptionStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.Subscription.status)
}
inline ::uprotocol::core::usubscription::v3::SubscriptionStatus* Subscription::release_status() {
  
  ::uprotocol::core::usubscription::v3::SubscriptionStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::core::usubscription::v3::SubscriptionStatus* Subscription::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.Subscription.status)
  
  ::uprotocol::core::usubscription::v3::SubscriptionStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::uprotocol::core::usubscription::v3::SubscriptionStatus* Subscription::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::core::usubscription::v3::SubscriptionStatus>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::uprotocol::core::usubscription::v3::SubscriptionStatus* Subscription::mutable_status() {
  ::uprotocol::core::usubscription::v3::SubscriptionStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.Subscription.status)
  return _msg;
}
inline void Subscription::set_allocated_status(::uprotocol::core::usubscription::v3::SubscriptionStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.Subscription.status)
}

// .uprotocol.core.usubscription.v3.SubscribeAttributes attributes = 4;
inline bool Subscription::_internal_has_attributes() const {
  return this != internal_default_instance() && _impl_.attributes_ != nullptr;
}
inline bool Subscription::has_attributes() const {
  return _internal_has_attributes();
}
inline void Subscription::clear_attributes() {
  if (GetArenaForAllocation() == nullptr && _impl_.attributes_ != nullptr) {
    delete _impl_.attributes_;
  }
  _impl_.attributes_ = nullptr;
}
inline const ::uprotocol::core::usubscription::v3::SubscribeAttributes& Subscription::_internal_attributes() const {
  const ::uprotocol::core::usubscription::v3::SubscribeAttributes* p = _impl_.attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::core::usubscription::v3::SubscribeAttributes&>(
      ::uprotocol::core::usubscription::v3::_SubscribeAttributes_default_instance_);
}
inline const ::uprotocol::core::usubscription::v3::SubscribeAttributes& Subscription::attributes() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.Subscription.attributes)
  return _internal_attributes();
}
inline void Subscription::unsafe_arena_set_allocated_attributes(
    ::uprotocol::core::usubscription::v3::SubscribeAttributes* attributes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attributes_);
  }
  _impl_.attributes_ = attributes;
  if (attributes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.Subscription.attributes)
}
inline ::uprotocol::core::usubscription::v3::SubscribeAttributes* Subscription::release_attributes() {
  
  ::uprotocol::core::usubscription::v3::SubscribeAttributes* temp = _impl_.attributes_;
  _impl_.attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::core::usubscription::v3::SubscribeAttributes* Subscription::unsafe_arena_release_attributes() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.Subscription.attributes)
  
  ::uprotocol::core::usubscription::v3::SubscribeAttributes* temp = _impl_.attributes_;
  _impl_.attributes_ = nullptr;
  return temp;
}
inline ::uprotocol::core::usubscription::v3::SubscribeAttributes* Subscription::_internal_mutable_attributes() {
  
  if (_impl_.attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::core::usubscription::v3::SubscribeAttributes>(GetArenaForAllocation());
    _impl_.attributes_ = p;
  }
  return _impl_.attributes_;
}
inline ::uprotocol::core::usubscription::v3::SubscribeAttributes* Subscription::mutable_attributes() {
  ::uprotocol::core::usubscription::v3::SubscribeAttributes* _msg = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.Subscription.attributes)
  return _msg;
}
inline void Subscription::set_allocated_attributes(::uprotocol::core::usubscription::v3::SubscribeAttributes* attributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.attributes_;
  }
  if (attributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attributes);
    if (message_arena != submessage_arena) {
      attributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attributes, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.attributes_ = attributes;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.Subscription.attributes)
}

// .uprotocol.core.usubscription.v3.EventDeliveryConfig config = 5;
inline bool Subscription::_internal_has_config() const {
  return this != internal_default_instance() && _impl_.config_ != nullptr;
}
inline bool Subscription::has_config() const {
  return _internal_has_config();
}
inline void Subscription::clear_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.config_ != nullptr) {
    delete _impl_.config_;
  }
  _impl_.config_ = nullptr;
}
inline const ::uprotocol::core::usubscription::v3::EventDeliveryConfig& Subscription::_internal_config() const {
  const ::uprotocol::core::usubscription::v3::EventDeliveryConfig* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::core::usubscription::v3::EventDeliveryConfig&>(
      ::uprotocol::core::usubscription::v3::_EventDeliveryConfig_default_instance_);
}
inline const ::uprotocol::core::usubscription::v3::EventDeliveryConfig& Subscription::config() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.Subscription.config)
  return _internal_config();
}
inline void Subscription::unsafe_arena_set_allocated_config(
    ::uprotocol::core::usubscription::v3::EventDeliveryConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.Subscription.config)
}
inline ::uprotocol::core::usubscription::v3::EventDeliveryConfig* Subscription::release_config() {
  
  ::uprotocol::core::usubscription::v3::EventDeliveryConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::core::usubscription::v3::EventDeliveryConfig* Subscription::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.Subscription.config)
  
  ::uprotocol::core::usubscription::v3::EventDeliveryConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::uprotocol::core::usubscription::v3::EventDeliveryConfig* Subscription::_internal_mutable_config() {
  
  if (_impl_.config_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::core::usubscription::v3::EventDeliveryConfig>(GetArenaForAllocation());
    _impl_.config_ = p;
  }
  return _impl_.config_;
}
inline ::uprotocol::core::usubscription::v3::EventDeliveryConfig* Subscription::mutable_config() {
  ::uprotocol::core::usubscription::v3::EventDeliveryConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.Subscription.config)
  return _msg;
}
inline void Subscription::set_allocated_config(::uprotocol::core::usubscription::v3::EventDeliveryConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.config_ = config;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.Subscription.config)
}

// -------------------------------------------------------------------

// FetchSubscriptionsRequest

// .uprotocol.v1.UUri topic = 1;
inline bool FetchSubscriptionsRequest::_internal_has_topic() const {
  return request_case() == kTopic;
}
inline bool FetchSubscriptionsRequest::has_topic() const {
  return _internal_has_topic();
}
inline void FetchSubscriptionsRequest::set_has_topic() {
  _impl_._oneof_case_[0] = kTopic;
}
inline ::uprotocol::v1::UUri* FetchSubscriptionsRequest::release_topic() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.FetchSubscriptionsRequest.topic)
  if (_internal_has_topic()) {
    clear_has_request();
    ::uprotocol::v1::UUri* temp = _impl_.request_.topic_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.topic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uprotocol::v1::UUri& FetchSubscriptionsRequest::_internal_topic() const {
  return _internal_has_topic()
      ? *_impl_.request_.topic_
      : reinterpret_cast< ::uprotocol::v1::UUri&>(::uprotocol::v1::_UUri_default_instance_);
}
inline const ::uprotocol::v1::UUri& FetchSubscriptionsRequest::topic() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.FetchSubscriptionsRequest.topic)
  return _internal_topic();
}
inline ::uprotocol::v1::UUri* FetchSubscriptionsRequest::unsafe_arena_release_topic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uprotocol.core.usubscription.v3.FetchSubscriptionsRequest.topic)
  if (_internal_has_topic()) {
    clear_has_request();
    ::uprotocol::v1::UUri* temp = _impl_.request_.topic_;
    _impl_.request_.topic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FetchSubscriptionsRequest::unsafe_arena_set_allocated_topic(::uprotocol::v1::UUri* topic) {
  clear_request();
  if (topic) {
    set_has_topic();
    _impl_.request_.topic_ = topic;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.FetchSubscriptionsRequest.topic)
}
inline ::uprotocol::v1::UUri* FetchSubscriptionsRequest::_internal_mutable_topic() {
  if (!_internal_has_topic()) {
    clear_request();
    set_has_topic();
    _impl_.request_.topic_ = CreateMaybeMessage< ::uprotocol::v1::UUri >(GetArenaForAllocation());
  }
  return _impl_.request_.topic_;
}
inline ::uprotocol::v1::UUri* FetchSubscriptionsRequest::mutable_topic() {
  ::uprotocol::v1::UUri* _msg = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.FetchSubscriptionsRequest.topic)
  return _msg;
}

// .uprotocol.core.usubscription.v3.SubscriberInfo subscriber = 2;
inline bool FetchSubscriptionsRequest::_internal_has_subscriber() const {
  return request_case() == kSubscriber;
}
inline bool FetchSubscriptionsRequest::has_subscriber() const {
  return _internal_has_subscriber();
}
inline void FetchSubscriptionsRequest::set_has_subscriber() {
  _impl_._oneof_case_[0] = kSubscriber;
}
inline void FetchSubscriptionsRequest::clear_subscriber() {
  if (_internal_has_subscriber()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.subscriber_;
    }
    clear_has_request();
  }
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* FetchSubscriptionsRequest::release_subscriber() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.FetchSubscriptionsRequest.subscriber)
  if (_internal_has_subscriber()) {
    clear_has_request();
    ::uprotocol::core::usubscription::v3::SubscriberInfo* temp = _impl_.request_.subscriber_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.subscriber_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::uprotocol::core::usubscription::v3::SubscriberInfo& FetchSubscriptionsRequest::_internal_subscriber() const {
  return _internal_has_subscriber()
      ? *_impl_.request_.subscriber_
      : reinterpret_cast< ::uprotocol::core::usubscription::v3::SubscriberInfo&>(::uprotocol::core::usubscription::v3::_SubscriberInfo_default_instance_);
}
inline const ::uprotocol::core::usubscription::v3::SubscriberInfo& FetchSubscriptionsRequest::subscriber() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.FetchSubscriptionsRequest.subscriber)
  return _internal_subscriber();
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* FetchSubscriptionsRequest::unsafe_arena_release_subscriber() {
  // @@protoc_insertion_point(field_unsafe_arena_release:uprotocol.core.usubscription.v3.FetchSubscriptionsRequest.subscriber)
  if (_internal_has_subscriber()) {
    clear_has_request();
    ::uprotocol::core::usubscription::v3::SubscriberInfo* temp = _impl_.request_.subscriber_;
    _impl_.request_.subscriber_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FetchSubscriptionsRequest::unsafe_arena_set_allocated_subscriber(::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber) {
  clear_request();
  if (subscriber) {
    set_has_subscriber();
    _impl_.request_.subscriber_ = subscriber;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.FetchSubscriptionsRequest.subscriber)
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* FetchSubscriptionsRequest::_internal_mutable_subscriber() {
  if (!_internal_has_subscriber()) {
    clear_request();
    set_has_subscriber();
    _impl_.request_.subscriber_ = CreateMaybeMessage< ::uprotocol::core::usubscription::v3::SubscriberInfo >(GetArenaForAllocation());
  }
  return _impl_.request_.subscriber_;
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* FetchSubscriptionsRequest::mutable_subscriber() {
  ::uprotocol::core::usubscription::v3::SubscriberInfo* _msg = _internal_mutable_subscriber();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.FetchSubscriptionsRequest.subscriber)
  return _msg;
}

// optional uint32 offset = 3;
inline bool FetchSubscriptionsRequest::_internal_has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FetchSubscriptionsRequest::has_offset() const {
  return _internal_has_offset();
}
inline void FetchSubscriptionsRequest::clear_offset() {
  _impl_.offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t FetchSubscriptionsRequest::_internal_offset() const {
  return _impl_.offset_;
}
inline uint32_t FetchSubscriptionsRequest::offset() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.FetchSubscriptionsRequest.offset)
  return _internal_offset();
}
inline void FetchSubscriptionsRequest::_internal_set_offset(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.offset_ = value;
}
inline void FetchSubscriptionsRequest::set_offset(uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:uprotocol.core.usubscription.v3.FetchSubscriptionsRequest.offset)
}

inline bool FetchSubscriptionsRequest::has_request() const {
  return request_case() != REQUEST_NOT_SET;
}
inline void FetchSubscriptionsRequest::clear_has_request() {
  _impl_._oneof_case_[0] = REQUEST_NOT_SET;
}
inline FetchSubscriptionsRequest::RequestCase FetchSubscriptionsRequest::request_case() const {
  return FetchSubscriptionsRequest::RequestCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// FetchSubscriptionsResponse

// repeated .uprotocol.core.usubscription.v3.Subscription subscriptions = 1;
inline int FetchSubscriptionsResponse::_internal_subscriptions_size() const {
  return _impl_.subscriptions_.size();
}
inline int FetchSubscriptionsResponse::subscriptions_size() const {
  return _internal_subscriptions_size();
}
inline void FetchSubscriptionsResponse::clear_subscriptions() {
  _impl_.subscriptions_.Clear();
}
inline ::uprotocol::core::usubscription::v3::Subscription* FetchSubscriptionsResponse::mutable_subscriptions(int index) {
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.FetchSubscriptionsResponse.subscriptions)
  return _impl_.subscriptions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uprotocol::core::usubscription::v3::Subscription >*
FetchSubscriptionsResponse::mutable_subscriptions() {
  // @@protoc_insertion_point(field_mutable_list:uprotocol.core.usubscription.v3.FetchSubscriptionsResponse.subscriptions)
  return &_impl_.subscriptions_;
}
inline const ::uprotocol::core::usubscription::v3::Subscription& FetchSubscriptionsResponse::_internal_subscriptions(int index) const {
  return _impl_.subscriptions_.Get(index);
}
inline const ::uprotocol::core::usubscription::v3::Subscription& FetchSubscriptionsResponse::subscriptions(int index) const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.FetchSubscriptionsResponse.subscriptions)
  return _internal_subscriptions(index);
}
inline ::uprotocol::core::usubscription::v3::Subscription* FetchSubscriptionsResponse::_internal_add_subscriptions() {
  return _impl_.subscriptions_.Add();
}
inline ::uprotocol::core::usubscription::v3::Subscription* FetchSubscriptionsResponse::add_subscriptions() {
  ::uprotocol::core::usubscription::v3::Subscription* _add = _internal_add_subscriptions();
  // @@protoc_insertion_point(field_add:uprotocol.core.usubscription.v3.FetchSubscriptionsResponse.subscriptions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::uprotocol::core::usubscription::v3::Subscription >&
FetchSubscriptionsResponse::subscriptions() const {
  // @@protoc_insertion_point(field_list:uprotocol.core.usubscription.v3.FetchSubscriptionsResponse.subscriptions)
  return _impl_.subscriptions_;
}

// optional bool has_more_records = 2;
inline bool FetchSubscriptionsResponse::_internal_has_has_more_records() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FetchSubscriptionsResponse::has_has_more_records() const {
  return _internal_has_has_more_records();
}
inline void FetchSubscriptionsResponse::clear_has_more_records() {
  _impl_.has_more_records_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool FetchSubscriptionsResponse::_internal_has_more_records() const {
  return _impl_.has_more_records_;
}
inline bool FetchSubscriptionsResponse::has_more_records() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.FetchSubscriptionsResponse.has_more_records)
  return _internal_has_more_records();
}
inline void FetchSubscriptionsResponse::_internal_set_has_more_records(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.has_more_records_ = value;
}
inline void FetchSubscriptionsResponse::set_has_more_records(bool value) {
  _internal_set_has_more_records(value);
  // @@protoc_insertion_point(field_set:uprotocol.core.usubscription.v3.FetchSubscriptionsResponse.has_more_records)
}

// .uprotocol.v1.UStatus status = 3;
inline bool FetchSubscriptionsResponse::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool FetchSubscriptionsResponse::has_status() const {
  return _internal_has_status();
}
inline const ::uprotocol::v1::UStatus& FetchSubscriptionsResponse::_internal_status() const {
  const ::uprotocol::v1::UStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::v1::UStatus&>(
      ::uprotocol::v1::_UStatus_default_instance_);
}
inline const ::uprotocol::v1::UStatus& FetchSubscriptionsResponse::status() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.FetchSubscriptionsResponse.status)
  return _internal_status();
}
inline void FetchSubscriptionsResponse::unsafe_arena_set_allocated_status(
    ::uprotocol::v1::UStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.FetchSubscriptionsResponse.status)
}
inline ::uprotocol::v1::UStatus* FetchSubscriptionsResponse::release_status() {
  
  ::uprotocol::v1::UStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::v1::UStatus* FetchSubscriptionsResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.FetchSubscriptionsResponse.status)
  
  ::uprotocol::v1::UStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::uprotocol::v1::UStatus* FetchSubscriptionsResponse::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::v1::UStatus>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::uprotocol::v1::UStatus* FetchSubscriptionsResponse::mutable_status() {
  ::uprotocol::v1::UStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.FetchSubscriptionsResponse.status)
  return _msg;
}
inline void FetchSubscriptionsResponse::set_allocated_status(::uprotocol::v1::UStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.FetchSubscriptionsResponse.status)
}

// -------------------------------------------------------------------

// NotificationsRequest

// .uprotocol.v1.UUri topic = 1;
inline bool NotificationsRequest::_internal_has_topic() const {
  return this != internal_default_instance() && _impl_.topic_ != nullptr;
}
inline bool NotificationsRequest::has_topic() const {
  return _internal_has_topic();
}
inline const ::uprotocol::v1::UUri& NotificationsRequest::_internal_topic() const {
  const ::uprotocol::v1::UUri* p = _impl_.topic_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::v1::UUri&>(
      ::uprotocol::v1::_UUri_default_instance_);
}
inline const ::uprotocol::v1::UUri& NotificationsRequest::topic() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.NotificationsRequest.topic)
  return _internal_topic();
}
inline void NotificationsRequest::unsafe_arena_set_allocated_topic(
    ::uprotocol::v1::UUri* topic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.topic_);
  }
  _impl_.topic_ = topic;
  if (topic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.NotificationsRequest.topic)
}
inline ::uprotocol::v1::UUri* NotificationsRequest::release_topic() {
  
  ::uprotocol::v1::UUri* temp = _impl_.topic_;
  _impl_.topic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::v1::UUri* NotificationsRequest::unsafe_arena_release_topic() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.NotificationsRequest.topic)
  
  ::uprotocol::v1::UUri* temp = _impl_.topic_;
  _impl_.topic_ = nullptr;
  return temp;
}
inline ::uprotocol::v1::UUri* NotificationsRequest::_internal_mutable_topic() {
  
  if (_impl_.topic_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::v1::UUri>(GetArenaForAllocation());
    _impl_.topic_ = p;
  }
  return _impl_.topic_;
}
inline ::uprotocol::v1::UUri* NotificationsRequest::mutable_topic() {
  ::uprotocol::v1::UUri* _msg = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.NotificationsRequest.topic)
  return _msg;
}
inline void NotificationsRequest::set_allocated_topic(::uprotocol::v1::UUri* topic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.topic_);
  }
  if (topic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic));
    if (message_arena != submessage_arena) {
      topic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topic, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.topic_ = topic;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.NotificationsRequest.topic)
}

// .uprotocol.core.usubscription.v3.SubscriberInfo subscriber = 2;
inline bool NotificationsRequest::_internal_has_subscriber() const {
  return this != internal_default_instance() && _impl_.subscriber_ != nullptr;
}
inline bool NotificationsRequest::has_subscriber() const {
  return _internal_has_subscriber();
}
inline void NotificationsRequest::clear_subscriber() {
  if (GetArenaForAllocation() == nullptr && _impl_.subscriber_ != nullptr) {
    delete _impl_.subscriber_;
  }
  _impl_.subscriber_ = nullptr;
}
inline const ::uprotocol::core::usubscription::v3::SubscriberInfo& NotificationsRequest::_internal_subscriber() const {
  const ::uprotocol::core::usubscription::v3::SubscriberInfo* p = _impl_.subscriber_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::core::usubscription::v3::SubscriberInfo&>(
      ::uprotocol::core::usubscription::v3::_SubscriberInfo_default_instance_);
}
inline const ::uprotocol::core::usubscription::v3::SubscriberInfo& NotificationsRequest::subscriber() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.NotificationsRequest.subscriber)
  return _internal_subscriber();
}
inline void NotificationsRequest::unsafe_arena_set_allocated_subscriber(
    ::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subscriber_);
  }
  _impl_.subscriber_ = subscriber;
  if (subscriber) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.NotificationsRequest.subscriber)
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* NotificationsRequest::release_subscriber() {
  
  ::uprotocol::core::usubscription::v3::SubscriberInfo* temp = _impl_.subscriber_;
  _impl_.subscriber_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* NotificationsRequest::unsafe_arena_release_subscriber() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.NotificationsRequest.subscriber)
  
  ::uprotocol::core::usubscription::v3::SubscriberInfo* temp = _impl_.subscriber_;
  _impl_.subscriber_ = nullptr;
  return temp;
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* NotificationsRequest::_internal_mutable_subscriber() {
  
  if (_impl_.subscriber_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::core::usubscription::v3::SubscriberInfo>(GetArenaForAllocation());
    _impl_.subscriber_ = p;
  }
  return _impl_.subscriber_;
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* NotificationsRequest::mutable_subscriber() {
  ::uprotocol::core::usubscription::v3::SubscriberInfo* _msg = _internal_mutable_subscriber();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.NotificationsRequest.subscriber)
  return _msg;
}
inline void NotificationsRequest::set_allocated_subscriber(::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.subscriber_;
  }
  if (subscriber) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(subscriber);
    if (message_arena != submessage_arena) {
      subscriber = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscriber, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.subscriber_ = subscriber;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.NotificationsRequest.subscriber)
}

// -------------------------------------------------------------------

// CreateTopicRequest

// .uprotocol.v1.UUri topic = 1;
inline bool CreateTopicRequest::_internal_has_topic() const {
  return this != internal_default_instance() && _impl_.topic_ != nullptr;
}
inline bool CreateTopicRequest::has_topic() const {
  return _internal_has_topic();
}
inline const ::uprotocol::v1::UUri& CreateTopicRequest::_internal_topic() const {
  const ::uprotocol::v1::UUri* p = _impl_.topic_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::v1::UUri&>(
      ::uprotocol::v1::_UUri_default_instance_);
}
inline const ::uprotocol::v1::UUri& CreateTopicRequest::topic() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.CreateTopicRequest.topic)
  return _internal_topic();
}
inline void CreateTopicRequest::unsafe_arena_set_allocated_topic(
    ::uprotocol::v1::UUri* topic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.topic_);
  }
  _impl_.topic_ = topic;
  if (topic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.CreateTopicRequest.topic)
}
inline ::uprotocol::v1::UUri* CreateTopicRequest::release_topic() {
  
  ::uprotocol::v1::UUri* temp = _impl_.topic_;
  _impl_.topic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::v1::UUri* CreateTopicRequest::unsafe_arena_release_topic() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.CreateTopicRequest.topic)
  
  ::uprotocol::v1::UUri* temp = _impl_.topic_;
  _impl_.topic_ = nullptr;
  return temp;
}
inline ::uprotocol::v1::UUri* CreateTopicRequest::_internal_mutable_topic() {
  
  if (_impl_.topic_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::v1::UUri>(GetArenaForAllocation());
    _impl_.topic_ = p;
  }
  return _impl_.topic_;
}
inline ::uprotocol::v1::UUri* CreateTopicRequest::mutable_topic() {
  ::uprotocol::v1::UUri* _msg = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.CreateTopicRequest.topic)
  return _msg;
}
inline void CreateTopicRequest::set_allocated_topic(::uprotocol::v1::UUri* topic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.topic_);
  }
  if (topic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic));
    if (message_arena != submessage_arena) {
      topic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topic, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.topic_ = topic;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.CreateTopicRequest.topic)
}

// -------------------------------------------------------------------

// DeprecateTopicRequest

// .uprotocol.v1.UUri topic = 1;
inline bool DeprecateTopicRequest::_internal_has_topic() const {
  return this != internal_default_instance() && _impl_.topic_ != nullptr;
}
inline bool DeprecateTopicRequest::has_topic() const {
  return _internal_has_topic();
}
inline const ::uprotocol::v1::UUri& DeprecateTopicRequest::_internal_topic() const {
  const ::uprotocol::v1::UUri* p = _impl_.topic_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::v1::UUri&>(
      ::uprotocol::v1::_UUri_default_instance_);
}
inline const ::uprotocol::v1::UUri& DeprecateTopicRequest::topic() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.DeprecateTopicRequest.topic)
  return _internal_topic();
}
inline void DeprecateTopicRequest::unsafe_arena_set_allocated_topic(
    ::uprotocol::v1::UUri* topic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.topic_);
  }
  _impl_.topic_ = topic;
  if (topic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.DeprecateTopicRequest.topic)
}
inline ::uprotocol::v1::UUri* DeprecateTopicRequest::release_topic() {
  
  ::uprotocol::v1::UUri* temp = _impl_.topic_;
  _impl_.topic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::v1::UUri* DeprecateTopicRequest::unsafe_arena_release_topic() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.DeprecateTopicRequest.topic)
  
  ::uprotocol::v1::UUri* temp = _impl_.topic_;
  _impl_.topic_ = nullptr;
  return temp;
}
inline ::uprotocol::v1::UUri* DeprecateTopicRequest::_internal_mutable_topic() {
  
  if (_impl_.topic_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::v1::UUri>(GetArenaForAllocation());
    _impl_.topic_ = p;
  }
  return _impl_.topic_;
}
inline ::uprotocol::v1::UUri* DeprecateTopicRequest::mutable_topic() {
  ::uprotocol::v1::UUri* _msg = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.DeprecateTopicRequest.topic)
  return _msg;
}
inline void DeprecateTopicRequest::set_allocated_topic(::uprotocol::v1::UUri* topic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.topic_);
  }
  if (topic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic));
    if (message_arena != submessage_arena) {
      topic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topic, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.topic_ = topic;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.DeprecateTopicRequest.topic)
}

// -------------------------------------------------------------------

// Update

// .uprotocol.v1.UUri topic = 1;
inline bool Update::_internal_has_topic() const {
  return this != internal_default_instance() && _impl_.topic_ != nullptr;
}
inline bool Update::has_topic() const {
  return _internal_has_topic();
}
inline const ::uprotocol::v1::UUri& Update::_internal_topic() const {
  const ::uprotocol::v1::UUri* p = _impl_.topic_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::v1::UUri&>(
      ::uprotocol::v1::_UUri_default_instance_);
}
inline const ::uprotocol::v1::UUri& Update::topic() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.Update.topic)
  return _internal_topic();
}
inline void Update::unsafe_arena_set_allocated_topic(
    ::uprotocol::v1::UUri* topic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.topic_);
  }
  _impl_.topic_ = topic;
  if (topic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.Update.topic)
}
inline ::uprotocol::v1::UUri* Update::release_topic() {
  
  ::uprotocol::v1::UUri* temp = _impl_.topic_;
  _impl_.topic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::v1::UUri* Update::unsafe_arena_release_topic() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.Update.topic)
  
  ::uprotocol::v1::UUri* temp = _impl_.topic_;
  _impl_.topic_ = nullptr;
  return temp;
}
inline ::uprotocol::v1::UUri* Update::_internal_mutable_topic() {
  
  if (_impl_.topic_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::v1::UUri>(GetArenaForAllocation());
    _impl_.topic_ = p;
  }
  return _impl_.topic_;
}
inline ::uprotocol::v1::UUri* Update::mutable_topic() {
  ::uprotocol::v1::UUri* _msg = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.Update.topic)
  return _msg;
}
inline void Update::set_allocated_topic(::uprotocol::v1::UUri* topic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.topic_);
  }
  if (topic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic));
    if (message_arena != submessage_arena) {
      topic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topic, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.topic_ = topic;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.Update.topic)
}

// .uprotocol.core.usubscription.v3.SubscriberInfo subscriber = 2;
inline bool Update::_internal_has_subscriber() const {
  return this != internal_default_instance() && _impl_.subscriber_ != nullptr;
}
inline bool Update::has_subscriber() const {
  return _internal_has_subscriber();
}
inline void Update::clear_subscriber() {
  if (GetArenaForAllocation() == nullptr && _impl_.subscriber_ != nullptr) {
    delete _impl_.subscriber_;
  }
  _impl_.subscriber_ = nullptr;
}
inline const ::uprotocol::core::usubscription::v3::SubscriberInfo& Update::_internal_subscriber() const {
  const ::uprotocol::core::usubscription::v3::SubscriberInfo* p = _impl_.subscriber_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::core::usubscription::v3::SubscriberInfo&>(
      ::uprotocol::core::usubscription::v3::_SubscriberInfo_default_instance_);
}
inline const ::uprotocol::core::usubscription::v3::SubscriberInfo& Update::subscriber() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.Update.subscriber)
  return _internal_subscriber();
}
inline void Update::unsafe_arena_set_allocated_subscriber(
    ::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subscriber_);
  }
  _impl_.subscriber_ = subscriber;
  if (subscriber) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.Update.subscriber)
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* Update::release_subscriber() {
  
  ::uprotocol::core::usubscription::v3::SubscriberInfo* temp = _impl_.subscriber_;
  _impl_.subscriber_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* Update::unsafe_arena_release_subscriber() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.Update.subscriber)
  
  ::uprotocol::core::usubscription::v3::SubscriberInfo* temp = _impl_.subscriber_;
  _impl_.subscriber_ = nullptr;
  return temp;
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* Update::_internal_mutable_subscriber() {
  
  if (_impl_.subscriber_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::core::usubscription::v3::SubscriberInfo>(GetArenaForAllocation());
    _impl_.subscriber_ = p;
  }
  return _impl_.subscriber_;
}
inline ::uprotocol::core::usubscription::v3::SubscriberInfo* Update::mutable_subscriber() {
  ::uprotocol::core::usubscription::v3::SubscriberInfo* _msg = _internal_mutable_subscriber();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.Update.subscriber)
  return _msg;
}
inline void Update::set_allocated_subscriber(::uprotocol::core::usubscription::v3::SubscriberInfo* subscriber) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.subscriber_;
  }
  if (subscriber) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(subscriber);
    if (message_arena != submessage_arena) {
      subscriber = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscriber, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.subscriber_ = subscriber;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.Update.subscriber)
}

// .uprotocol.core.usubscription.v3.SubscriptionStatus status = 3;
inline bool Update::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool Update::has_status() const {
  return _internal_has_status();
}
inline void Update::clear_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
}
inline const ::uprotocol::core::usubscription::v3::SubscriptionStatus& Update::_internal_status() const {
  const ::uprotocol::core::usubscription::v3::SubscriptionStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::core::usubscription::v3::SubscriptionStatus&>(
      ::uprotocol::core::usubscription::v3::_SubscriptionStatus_default_instance_);
}
inline const ::uprotocol::core::usubscription::v3::SubscriptionStatus& Update::status() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.Update.status)
  return _internal_status();
}
inline void Update::unsafe_arena_set_allocated_status(
    ::uprotocol::core::usubscription::v3::SubscriptionStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.Update.status)
}
inline ::uprotocol::core::usubscription::v3::SubscriptionStatus* Update::release_status() {
  
  ::uprotocol::core::usubscription::v3::SubscriptionStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::core::usubscription::v3::SubscriptionStatus* Update::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.Update.status)
  
  ::uprotocol::core::usubscription::v3::SubscriptionStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::uprotocol::core::usubscription::v3::SubscriptionStatus* Update::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::core::usubscription::v3::SubscriptionStatus>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::uprotocol::core::usubscription::v3::SubscriptionStatus* Update::mutable_status() {
  ::uprotocol::core::usubscription::v3::SubscriptionStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.Update.status)
  return _msg;
}
inline void Update::set_allocated_status(::uprotocol::core::usubscription::v3::SubscriptionStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.Update.status)
}

// .uprotocol.core.usubscription.v3.SubscribeAttributes attributes = 4;
inline bool Update::_internal_has_attributes() const {
  return this != internal_default_instance() && _impl_.attributes_ != nullptr;
}
inline bool Update::has_attributes() const {
  return _internal_has_attributes();
}
inline void Update::clear_attributes() {
  if (GetArenaForAllocation() == nullptr && _impl_.attributes_ != nullptr) {
    delete _impl_.attributes_;
  }
  _impl_.attributes_ = nullptr;
}
inline const ::uprotocol::core::usubscription::v3::SubscribeAttributes& Update::_internal_attributes() const {
  const ::uprotocol::core::usubscription::v3::SubscribeAttributes* p = _impl_.attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::core::usubscription::v3::SubscribeAttributes&>(
      ::uprotocol::core::usubscription::v3::_SubscribeAttributes_default_instance_);
}
inline const ::uprotocol::core::usubscription::v3::SubscribeAttributes& Update::attributes() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.Update.attributes)
  return _internal_attributes();
}
inline void Update::unsafe_arena_set_allocated_attributes(
    ::uprotocol::core::usubscription::v3::SubscribeAttributes* attributes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attributes_);
  }
  _impl_.attributes_ = attributes;
  if (attributes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.Update.attributes)
}
inline ::uprotocol::core::usubscription::v3::SubscribeAttributes* Update::release_attributes() {
  
  ::uprotocol::core::usubscription::v3::SubscribeAttributes* temp = _impl_.attributes_;
  _impl_.attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::core::usubscription::v3::SubscribeAttributes* Update::unsafe_arena_release_attributes() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.Update.attributes)
  
  ::uprotocol::core::usubscription::v3::SubscribeAttributes* temp = _impl_.attributes_;
  _impl_.attributes_ = nullptr;
  return temp;
}
inline ::uprotocol::core::usubscription::v3::SubscribeAttributes* Update::_internal_mutable_attributes() {
  
  if (_impl_.attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::core::usubscription::v3::SubscribeAttributes>(GetArenaForAllocation());
    _impl_.attributes_ = p;
  }
  return _impl_.attributes_;
}
inline ::uprotocol::core::usubscription::v3::SubscribeAttributes* Update::mutable_attributes() {
  ::uprotocol::core::usubscription::v3::SubscribeAttributes* _msg = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.Update.attributes)
  return _msg;
}
inline void Update::set_allocated_attributes(::uprotocol::core::usubscription::v3::SubscribeAttributes* attributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.attributes_;
  }
  if (attributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attributes);
    if (message_arena != submessage_arena) {
      attributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attributes, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.attributes_ = attributes;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.Update.attributes)
}

// -------------------------------------------------------------------

// SubscriptionChangeNotification

// .uprotocol.core.usubscription.v3.Update.Resources resource_name = 1 [(.uprotocol.resource_name_mask) = "*"];
inline void SubscriptionChangeNotification::clear_resource_name() {
  _impl_.resource_name_ = 0;
}
inline ::uprotocol::core::usubscription::v3::Update_Resources SubscriptionChangeNotification::_internal_resource_name() const {
  return static_cast< ::uprotocol::core::usubscription::v3::Update_Resources >(_impl_.resource_name_);
}
inline ::uprotocol::core::usubscription::v3::Update_Resources SubscriptionChangeNotification::resource_name() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.SubscriptionChangeNotification.resource_name)
  return _internal_resource_name();
}
inline void SubscriptionChangeNotification::_internal_set_resource_name(::uprotocol::core::usubscription::v3::Update_Resources value) {
  
  _impl_.resource_name_ = value;
}
inline void SubscriptionChangeNotification::set_resource_name(::uprotocol::core::usubscription::v3::Update_Resources value) {
  _internal_set_resource_name(value);
  // @@protoc_insertion_point(field_set:uprotocol.core.usubscription.v3.SubscriptionChangeNotification.resource_name)
}

// -------------------------------------------------------------------

// PassiveMode

// bool enable = 1;
inline void PassiveMode::clear_enable() {
  _impl_.enable_ = false;
}
inline bool PassiveMode::_internal_enable() const {
  return _impl_.enable_;
}
inline bool PassiveMode::enable() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.PassiveMode.enable)
  return _internal_enable();
}
inline void PassiveMode::_internal_set_enable(bool value) {
  
  _impl_.enable_ = value;
}
inline void PassiveMode::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:uprotocol.core.usubscription.v3.PassiveMode.enable)
}

// -------------------------------------------------------------------

// ResetRequest_Reason

// .uprotocol.core.usubscription.v3.ResetRequest.Reason.Code code = 1;
inline void ResetRequest_Reason::clear_code() {
  _impl_.code_ = 0;
}
inline ::uprotocol::core::usubscription::v3::ResetRequest_Reason_Code ResetRequest_Reason::_internal_code() const {
  return static_cast< ::uprotocol::core::usubscription::v3::ResetRequest_Reason_Code >(_impl_.code_);
}
inline ::uprotocol::core::usubscription::v3::ResetRequest_Reason_Code ResetRequest_Reason::code() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.ResetRequest.Reason.code)
  return _internal_code();
}
inline void ResetRequest_Reason::_internal_set_code(::uprotocol::core::usubscription::v3::ResetRequest_Reason_Code value) {
  
  _impl_.code_ = value;
}
inline void ResetRequest_Reason::set_code(::uprotocol::core::usubscription::v3::ResetRequest_Reason_Code value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:uprotocol.core.usubscription.v3.ResetRequest.Reason.code)
}

// optional string message = 2;
inline bool ResetRequest_Reason::_internal_has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResetRequest_Reason::has_message() const {
  return _internal_has_message();
}
inline void ResetRequest_Reason::clear_message() {
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResetRequest_Reason::message() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.ResetRequest.Reason.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResetRequest_Reason::set_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:uprotocol.core.usubscription.v3.ResetRequest.Reason.message)
}
inline std::string* ResetRequest_Reason::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.ResetRequest.Reason.message)
  return _s;
}
inline const std::string& ResetRequest_Reason::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ResetRequest_Reason::_internal_set_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ResetRequest_Reason::_internal_mutable_message() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ResetRequest_Reason::release_message() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.ResetRequest.Reason.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResetRequest_Reason::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.ResetRequest.Reason.message)
}

// -------------------------------------------------------------------

// ResetRequest

// optional .uprotocol.core.usubscription.v3.ResetRequest.Reason reason = 1;
inline bool ResetRequest::_internal_has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.reason_ != nullptr);
  return value;
}
inline bool ResetRequest::has_reason() const {
  return _internal_has_reason();
}
inline void ResetRequest::clear_reason() {
  if (_impl_.reason_ != nullptr) _impl_.reason_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::uprotocol::core::usubscription::v3::ResetRequest_Reason& ResetRequest::_internal_reason() const {
  const ::uprotocol::core::usubscription::v3::ResetRequest_Reason* p = _impl_.reason_;
  return p != nullptr ? *p : reinterpret_cast<const ::uprotocol::core::usubscription::v3::ResetRequest_Reason&>(
      ::uprotocol::core::usubscription::v3::_ResetRequest_Reason_default_instance_);
}
inline const ::uprotocol::core::usubscription::v3::ResetRequest_Reason& ResetRequest::reason() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.ResetRequest.reason)
  return _internal_reason();
}
inline void ResetRequest::unsafe_arena_set_allocated_reason(
    ::uprotocol::core::usubscription::v3::ResetRequest_Reason* reason) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reason_);
  }
  _impl_.reason_ = reason;
  if (reason) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.ResetRequest.reason)
}
inline ::uprotocol::core::usubscription::v3::ResetRequest_Reason* ResetRequest::release_reason() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::uprotocol::core::usubscription::v3::ResetRequest_Reason* temp = _impl_.reason_;
  _impl_.reason_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::uprotocol::core::usubscription::v3::ResetRequest_Reason* ResetRequest::unsafe_arena_release_reason() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.ResetRequest.reason)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::uprotocol::core::usubscription::v3::ResetRequest_Reason* temp = _impl_.reason_;
  _impl_.reason_ = nullptr;
  return temp;
}
inline ::uprotocol::core::usubscription::v3::ResetRequest_Reason* ResetRequest::_internal_mutable_reason() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.reason_ == nullptr) {
    auto* p = CreateMaybeMessage<::uprotocol::core::usubscription::v3::ResetRequest_Reason>(GetArenaForAllocation());
    _impl_.reason_ = p;
  }
  return _impl_.reason_;
}
inline ::uprotocol::core::usubscription::v3::ResetRequest_Reason* ResetRequest::mutable_reason() {
  ::uprotocol::core::usubscription::v3::ResetRequest_Reason* _msg = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.ResetRequest.reason)
  return _msg;
}
inline void ResetRequest::set_allocated_reason(::uprotocol::core::usubscription::v3::ResetRequest_Reason* reason) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.reason_;
  }
  if (reason) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reason);
    if (message_arena != submessage_arena) {
      reason = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reason, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.reason_ = reason;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.ResetRequest.reason)
}

// optional .google.protobuf.Timestamp before = 2;
inline bool ResetRequest::_internal_has_before() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.before_ != nullptr);
  return value;
}
inline bool ResetRequest::has_before() const {
  return _internal_has_before();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ResetRequest::_internal_before() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.before_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ResetRequest::before() const {
  // @@protoc_insertion_point(field_get:uprotocol.core.usubscription.v3.ResetRequest.before)
  return _internal_before();
}
inline void ResetRequest::unsafe_arena_set_allocated_before(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* before) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.before_);
  }
  _impl_.before_ = before;
  if (before) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uprotocol.core.usubscription.v3.ResetRequest.before)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ResetRequest::release_before() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.before_;
  _impl_.before_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ResetRequest::unsafe_arena_release_before() {
  // @@protoc_insertion_point(field_release:uprotocol.core.usubscription.v3.ResetRequest.before)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.before_;
  _impl_.before_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ResetRequest::_internal_mutable_before() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.before_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.before_ = p;
  }
  return _impl_.before_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ResetRequest::mutable_before() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_before();
  // @@protoc_insertion_point(field_mutable:uprotocol.core.usubscription.v3.ResetRequest.before)
  return _msg;
}
inline void ResetRequest::set_allocated_before(::PROTOBUF_NAMESPACE_ID::Timestamp* before) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.before_);
  }
  if (before) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(before));
    if (message_arena != submessage_arena) {
      before = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, before, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.before_ = before;
  // @@protoc_insertion_point(field_set_allocated:uprotocol.core.usubscription.v3.ResetRequest.before)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v3
}  // namespace usubscription
}  // namespace core
}  // namespace uprotocol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::uprotocol::core::usubscription::v3::SubscriptionStatus_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::uprotocol::core::usubscription::v3::SubscriptionStatus_State>() {
  return ::uprotocol::core::usubscription::v3::SubscriptionStatus_State_descriptor();
}
template <> struct is_proto_enum< ::uprotocol::core::usubscription::v3::Update_Resources> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::uprotocol::core::usubscription::v3::Update_Resources>() {
  return ::uprotocol::core::usubscription::v3::Update_Resources_descriptor();
}
template <> struct is_proto_enum< ::uprotocol::core::usubscription::v3::ResetRequest_Reason_Code> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::uprotocol::core::usubscription::v3::ResetRequest_Reason_Code>() {
  return ::uprotocol::core::usubscription::v3::ResetRequest_Reason_Code_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_core_2fusubscription_2fv3_2fusubscription_2eproto
