// SPDX-FileCopyrightText: 2024 Contributors to the Eclipse Foundation
//
// See the NOTICE file(s) distributed with this work for additional
// information regarding copyright ownership.
//
// This program and the accompanying materials are made available under the
// terms of the Apache License Version 2.0 which is available at
// https://www.apache.org/licenses/LICENSE-2.0
//
// SPDX-License-Identifier: Apache-2.0

#include <gtest/gtest.h>

#include "up-cpp/datamodel/builder/Uuid.h"
#include "up-cpp/datamodel/constants/UuidConstants.h"

namespace uprotocol::datamodel {

class TestUuidBuilder : public testing::Test {
protected:
	void SetUp() override {}
	void TearDown() override {}

	TestUuidBuilder() = default;

	static void SetUpTestSuite() {}
	static void TearDownTestSuite() {}

public:
	~TestUuidBuilder() override = default;
};

// Test getBuilder
TEST(UuidBuilderTest, GetBuilder) {  // NOLINT
	auto builder = builder::UuidBuilder::getBuilder();
	auto uuid = builder.build();

	EXPECT_TRUE(uuid.msb());
	EXPECT_TRUE(uuid.lsb());
}

// Test GetTestBuilder
TEST(UuidBuilderTest, GetTestBuilder) {  // NOLINT
	auto builder = builder::UuidBuilder::getTestBuilder();
	auto uuid = builder.build();

	EXPECT_TRUE(uuid.msb());
	EXPECT_TRUE(uuid.lsb());
}

// Test TestBuilder with time source
TEST(UuidBuilderTest, WithTimeSource) {  // NOLINT
	constexpr std::time_t FIXED_TIME_T = 1234567890;
	auto fixed_time = std::chrono::system_clock::from_time_t(FIXED_TIME_T);
	auto fixed_time_ms =
	    std::chrono::time_point_cast<std::chrono::milliseconds>(fixed_time);
	auto builder = builder::UuidBuilder::getTestBuilder().withTimeSource(
	    [fixed_time]() { return fixed_time; });
	auto uuid = builder.build();

	EXPECT_EQ(uuid.msb() >> UUID_TIMESTAMP_SHIFT,
	          fixed_time_ms.time_since_epoch().count());
}

// Test RandomSource
TEST(UuidBuilderTest, WithRandomSource) {  // NOLINT
	constexpr uint64_t FIXED_RANDOM_UINT = 0x1234567890ABCDEF;
	uint64_t fixed_random = FIXED_RANDOM_UINT;
	auto builder = builder::UuidBuilder::getTestBuilder().withRandomSource(
	    [fixed_random]() { return fixed_random; });
	auto uuid = builder.build();

	EXPECT_EQ(uuid.msb() & UUID_RANDOM_A_MASK,
	          fixed_random & UUID_RANDOM_A_MASK);
	EXPECT_EQ(uuid.lsb() & UUID_RANDOM_B_MASK,
	          fixed_random & UUID_RANDOM_B_MASK);
}

// Test independent state
TEST(UuidBuilderTest, Unguessability) {  // NOLINT
	auto builder1 = builder::UuidBuilder::getBuilder();
	auto builder2 = builder::UuidBuilder::getBuilder();

	{
		// Check that rand fields generated by different builders are different
		auto uuid1 = builder1.build();
		auto uuid2 = builder2.build();

		EXPECT_NE(uuid1.msb() & UUID_RANDOM_A_MASK,
		          uuid2.msb() & UUID_RANDOM_A_MASK);
		EXPECT_NE(uuid1.lsb() & UUID_RANDOM_B_MASK,
		          uuid2.lsb() & UUID_RANDOM_B_MASK);
	}

	{
		// Check that rand fields generated by the same builder are different
		auto uuid1 = builder1.build();
		auto uuid2 = builder1.build();

		EXPECT_NE(uuid1.msb() & UUID_RANDOM_A_MASK,
		          uuid2.msb() & UUID_RANDOM_A_MASK);
		EXPECT_NE(uuid1.lsb() & UUID_RANDOM_B_MASK,
		          uuid2.lsb() & UUID_RANDOM_B_MASK);
	}
}

// Test exception thrown
TEST(UuidBuilderTest, TestModeOnly) {  // NOLINT
	auto builder = builder::UuidBuilder::getBuilder();

	EXPECT_THROW(builder.withTimeSource(  // NOLINT
	                 []() { return std::chrono::system_clock::now(); }),
	             std::domain_error);
	EXPECT_THROW(builder.withRandomSource(  // NOLINT
	                 []() { return 0x1234567890ABCDEF; }),
	             std::domain_error);
}

// Test version and variant
TEST_F(TestUuidBuilder, CheckVersionAndVariant) {  // NOLINT
	auto builder = builder::UuidBuilder::getBuilder();
	auto uuid = builder.build();

	EXPECT_EQ((uuid.msb() >> UUID_VERSION_SHIFT) & UUID_VERSION_MASK,
	          UUID_VERSION_7);
	EXPECT_EQ((uuid.lsb() >> UUID_VARIANT_SHIFT) & UUID_VARIANT_MASK,
	          UUID_VARIANT_RFC4122);
}

// Test custom time and random source with builder
TEST(UuidBuilderTest, CustomTimeAndRandomSource) {  // NOLINT
	constexpr std::time_t FIXED_TIME_T = 1623456789;
	constexpr uint64_t FIXED_RANDOM_UINT = 0x1234567890ABCDEF;
	// Create a custom time source that returns a fixed timestamp
	auto fixed_time = std::chrono::system_clock::from_time_t(FIXED_TIME_T);
	auto time_source = [fixed_time]() { return fixed_time; };

	// Create a custom random source that returns a fixed random value
	uint64_t fixed_random = FIXED_RANDOM_UINT;
	auto random_source = [fixed_random]() { return fixed_random; };

	// Create a UuidBuilder with the custom time and random sources
	auto builder = builder::UuidBuilder::getTestBuilder()
	                   .withTimeSource(time_source)
	                   .withRandomSource(random_source);

	// Generate a UUID using the custom sources
	auto uuid = builder.build();

	// Extract the timestamp and random value from the generated UUID
	uint64_t timestamp = uuid.msb() >> UUID_TIMESTAMP_SHIFT;
	uint64_t random_value = uuid.lsb() & UUID_RANDOM_B_MASK;

	// Convert the fixed timestamp to milliseconds
	auto fixed_time_ms = std::chrono::duration_cast<std::chrono::milliseconds>(
	                         fixed_time.time_since_epoch())
	                         .count();

	// Check if the generated UUID matches the expected values
	EXPECT_EQ(timestamp, fixed_time_ms);
	EXPECT_EQ(random_value, fixed_random);
}

}  // namespace uprotocol::datamodel
